diff --git a/lib/auth_anon.c b/lib/auth_anon.c
index fce66d1..6520a9c 100644
--- a/lib/auth_anon.c
+++ b/lib/auth_anon.c
@@ -101,7 +101,7 @@ gen_anon_server_kx (gnutls_session_t session, opaque ** data)
 
   _gnutls_dh_set_group (session, g, p);
 
-  ret = _gnutls_dh_common_print_server_kx (session, g, p, data, 0);
+  ret = _gnutls_dh_common_print_server_kx (session, g, p, data, NULL);
   if (ret < 0)
     {
       gnutls_assert ();
@@ -163,7 +163,7 @@ proc_anon_server_kx (gnutls_session_t session, opaque * data,
       return ret;
     }
 
-  ret = _gnutls_proc_dh_common_server_kx (session, data, _data_size, 0);
+  ret = _gnutls_proc_dh_common_server_kx (session, data, _data_size);
   if (ret < 0)
     {
       gnutls_assert ();
diff --git a/lib/auth_dh_common.c b/lib/auth_dh_common.c
index acc574c..87c050f 100644
--- a/lib/auth_dh_common.c
+++ b/lib/auth_dh_common.c
@@ -222,7 +222,7 @@ error:
 
 int
 _gnutls_proc_dh_common_server_kx (gnutls_session_t session,
-                                  opaque * data, size_t _data_size, int psk)
+                                  opaque * data, size_t _data_size)
 {
   uint16_t n_Y, n_g, n_p;
   size_t _n_Y, _n_g, _n_p;
@@ -234,14 +234,6 @@ _gnutls_proc_dh_common_server_kx (gnutls_session_t session,
 
   i = 0;
 
-  if (psk != 0)
-    {
-      DECR_LEN (data_size, 2);
-      psk_size = _gnutls_read_uint16 (&data[i]);
-      DECR_LEN (data_size, psk_size);
-      i += 2 + psk_size;
-    }
-
   DECR_LEN (data_size, 2);
   n_p = _gnutls_read_uint16 (&data[i]);
   i += 2;
@@ -307,8 +299,6 @@ _gnutls_proc_dh_common_server_kx (gnutls_session_t session,
   _gnutls_dh_set_peer_public (session, session->key->client_Y);
 
   ret = n_Y + n_p + n_g + 6;
-  if (psk != 0)
-    ret += 2;
 
   return ret;
 }
@@ -318,7 +308,7 @@ _gnutls_proc_dh_common_server_kx (gnutls_session_t session,
 int
 _gnutls_dh_common_print_server_kx (gnutls_session_t session,
                                    bigint_t g, bigint_t p, opaque ** data,
-                                   int psk)
+                                   gnutls_datum_t *psk_hint)
 {
   bigint_t x, X;
   size_t n_X, n_g, n_p;
@@ -340,8 +330,8 @@ _gnutls_dh_common_print_server_kx (gnutls_session_t session,
   _gnutls_mpi_print (X, NULL, &n_X);
 
   data_size = n_g + n_p + n_X + 6;
-  if (psk != 0)
-    data_size += 2;
+  if (psk_hint != NULL)
+    data_size += 2 + psk_hint->size;
 
   (*data) = gnutls_malloc (data_size);
   if (*data == NULL)
@@ -353,10 +343,15 @@ _gnutls_dh_common_print_server_kx (gnutls_session_t session,
   pos = 0;
   pdata = *data;
 
-  if (psk != 0)
+  if (psk_hint != NULL)
     {
-      _gnutls_write_uint16 (0, &pdata[pos]);
+      _gnutls_write_uint16 (psk_hint->size, &pdata[pos]);
       pos += 2;
+      if (psk_hint->size > 0)
+        {
+          memcpy(&pdata[pos], psk_hint->data, psk_hint->size);
+          pos += psk_hint->size;
+        }
     }
 
   _gnutls_mpi_print (p, &pdata[pos + 2], &n_p);
@@ -378,8 +373,8 @@ _gnutls_dh_common_print_server_kx (gnutls_session_t session,
    * have been pessimist and might have returned initially
    * more data */
   ret = n_g + n_p + n_X + 6;
-  if (psk != 0)
-    ret += 2;
+  if (psk_hint != NULL)
+    ret += 2 + psk_hint->size;
 
   return ret;
 }
diff --git a/lib/auth_dh_common.h b/lib/auth_dh_common.h
index b934fd3..5301527 100644
--- a/lib/auth_dh_common.h
+++ b/lib/auth_dh_common.h
@@ -42,8 +42,8 @@ int _gnutls_proc_dh_common_client_kx (gnutls_session_t session,
                                       opaque * data, size_t _data_size,
                                       bigint_t p, bigint_t g);
 int _gnutls_dh_common_print_server_kx (gnutls_session_t, bigint_t g,
-                                       bigint_t p, opaque ** data, int psk);
+                                       bigint_t p, opaque ** data, gnutls_datum_t *psk_hint);
 int _gnutls_proc_dh_common_server_kx (gnutls_session_t session, opaque * data,
-                                      size_t _data_size, int psk);
+                                      size_t _data_size);
 
 #endif
diff --git a/lib/auth_dhe.c b/lib/auth_dhe.c
index 87de684..b12a971 100644
--- a/lib/auth_dhe.c
+++ b/lib/auth_dhe.c
@@ -133,7 +133,7 @@ gen_dhe_server_kx (gnutls_session_t session, opaque ** data)
 
   _gnutls_dh_set_group (session, g, p);
 
-  ret = _gnutls_dh_common_print_server_kx (session, g, p, data, 0);
+  ret = _gnutls_dh_common_print_server_kx (session, g, p, data, NULL);
   if (ret < 0)
     {
       gnutls_assert ();
@@ -229,7 +229,7 @@ proc_dhe_server_kx (gnutls_session_t session, opaque * data,
       return GNUTLS_E_INTERNAL_ERROR;
     }
 
-  ret = _gnutls_proc_dh_common_server_kx (session, data, _data_size, 0);
+  ret = _gnutls_proc_dh_common_server_kx (session, data, _data_size);
   if (ret < 0)
     {
       gnutls_assert ();
diff --git a/lib/auth_dhe_psk.c b/lib/auth_dhe_psk.c
index d6333bf..aa740bd 100644
--- a/lib/auth_dhe_psk.c
+++ b/lib/auth_dhe_psk.c
@@ -126,6 +126,7 @@ gen_psk_server_kx (gnutls_session_t session, opaque ** data)
   int ret;
   gnutls_dh_params_t dh_params;
   gnutls_psk_server_credentials_t cred;
+  gnutls_datum_t hint = {NULL, 0};
 
   cred = (gnutls_psk_server_credentials_t)
     _gnutls_get_cred (session->key, GNUTLS_CRD_PSK, NULL);
@@ -157,7 +158,13 @@ gen_psk_server_kx (gnutls_session_t session, opaque ** data)
 
   _gnutls_dh_set_group (session, g, p);
 
-  ret = _gnutls_dh_common_print_server_kx (session, g, p, data, 1);
+  if (cred->hint)
+    {
+      hint.data = (uint8_t *) cred->hint;
+      hint.size = strlen(cred->hint);
+    }
+
+  ret = _gnutls_dh_common_print_server_kx (session, g, p, data, &hint);
   if (ret < 0)
     {
       gnutls_assert ();
@@ -238,12 +245,37 @@ proc_psk_client_kx (gnutls_session_t session, opaque * data,
 
 }
 
+static int copy_hint(gnutls_session_t session, gnutls_datum_t *hint)
+{
+	psk_auth_info_t info;
+
+	/* copy the hint to the auth info structures
+	 */
+	info = _gnutls_get_auth_info(session);
+	if (info == NULL) {
+		gnutls_assert();
+		return GNUTLS_E_INTERNAL_ERROR;
+	}
+
+	if (hint->size > MAX_USERNAME_SIZE) {
+		gnutls_assert();
+		return GNUTLS_E_ILLEGAL_SRP_USERNAME;
+	}
+
+	memcpy(info->hint, hint->data, hint->size);
+	info->hint[hint->size] = 0;
+
+	return 0;
+}
+
 int
 proc_psk_server_kx (gnutls_session_t session, opaque * data,
                     size_t _data_size)
 {
 
   int ret;
+  gnutls_datum_t hint;
+  ssize_t data_size = _data_size;
 
   /* set auth_info */
   if ((ret =
@@ -254,7 +286,21 @@ proc_psk_server_kx (gnutls_session_t session, opaque * data,
       return ret;
     }
 
-  ret = _gnutls_proc_dh_common_server_kx (session, data, _data_size, 1);
+  DECR_LEN(data_size, 2);
+  hint.size = _gnutls_read_uint16(&data[0]);
+  hint.data = &data[2];
+
+  DECR_LEN(data_size, hint.size);
+  data += 2 + hint.size;
+
+  ret = copy_hint(session, &hint);
+  if (ret < 0)
+    {
+      gnutls_assert();
+      return ret;
+    }
+
+  ret = _gnutls_proc_dh_common_server_kx (session, data, data_size);
   if (ret < 0)
     {
       gnutls_assert ();
diff --git a/tests/pskself.c b/tests/pskself.c
index b04bd19..5926346 100644
--- a/tests/pskself.c
+++ b/tests/pskself.c
@@ -1,5 +1,6 @@
 /*
- * Copyright (C) 2004, 2005, 2008, 2010 Free Software Foundation, Inc.
+ * Copyright (C) 2004-2012 Free Software Foundation, Inc.
+ * Copyright (C) 2013 Adam Sampson <ats@offog.org>
  *
  * Author: Simon Josefsson
  *
@@ -28,310 +29,288 @@
 
 #include <stdio.h>
 #include <stdlib.h>
+
+#if defined(_WIN32)
+
+/* socketpair isn't supported on Win32. */
+int main(int argc, char **argv)
+{
+	exit(77);
+}
+
+#else
+
 #include <string.h>
 #include <sys/types.h>
-#if !defined(_WIN32)
 #include <sys/socket.h>
+#if !defined(_WIN32)
 #include <sys/wait.h>
-#include <netinet/in.h>
-#include <arpa/inet.h>
 #endif
 #include <unistd.h>
 #include <gnutls/gnutls.h>
 
-#include "tcp.c"
-
 #include "utils.h"
 
 /* A very basic TLS client, with PSK authentication.
  */
 
+const char *side = "";
+
+static void tls_log_func(int level, const char *str)
+{
+	fprintf(stderr, "%s|<%d>| %s", side, level, str);
+}
+
 #define MAX_BUF 1024
 #define MSG "Hello TLS"
 
-static void
-client (void)
+static void client(int sd, const char *prio)
 {
-  int ret, sd, ii;
-  gnutls_session_t session;
-  char buffer[MAX_BUF + 1];
-  gnutls_psk_client_credentials_t pskcred;
-  /* Need to enable anonymous KX specifically. */
-  const gnutls_datum_t key = { (char *) "DEADBEEF", 8 };
-
-  gnutls_global_init ();
-
-  gnutls_psk_allocate_client_credentials (&pskcred);
-  gnutls_psk_set_client_credentials (pskcred, "test", &key,
-                                     GNUTLS_PSK_KEY_HEX);
-
-  /* Initialize TLS session
-   */
-  gnutls_init (&session, GNUTLS_CLIENT);
-
-  /* Use default priorities */
-  gnutls_priority_set_direct (session, "NORMAL:+PSK", NULL);
-
-  /* put the anonymous credentials to the current session
-   */
-  gnutls_credentials_set (session, GNUTLS_CRD_PSK, pskcred);
-
-  /* connect to the peer
-   */
-  sd = tcp_connect ();
-
-  gnutls_transport_set_ptr (session, (gnutls_transport_ptr_t) sd);
-
-  /* Perform the TLS handshake
-   */
-  ret = gnutls_handshake (session);
-
-  if (ret < 0)
-    {
-      fail ("client: Handshake failed\n");
-      gnutls_perror (ret);
-      goto end;
-    }
-  else
-    {
-      if (debug)
-        success ("client: Handshake was completed\n");
-    }
-
-  gnutls_record_send (session, MSG, strlen (MSG));
-
-  ret = gnutls_record_recv (session, buffer, MAX_BUF);
-  if (ret == 0)
-    {
-      if (debug)
-        success ("client: Peer has closed the TLS connection\n");
-      goto end;
-    }
-  else if (ret < 0)
-    {
-      fail ("client: Error: %s\n", gnutls_strerror (ret));
-      goto end;
-    }
-
-  if (debug)
-    {
-      printf ("- Received %d bytes: ", ret);
-      for (ii = 0; ii < ret; ii++)
-        {
-          fputc (buffer[ii], stdout);
-        }
-      fputs ("\n", stdout);
-    }
-
-  gnutls_bye (session, GNUTLS_SHUT_RDWR);
-
-end:
-
-  tcp_close (sd);
-
-  gnutls_deinit (session);
-
-  gnutls_psk_free_client_credentials (pskcred);
-
-  gnutls_global_deinit ();
+	int ret, ii;
+	gnutls_session_t session;
+	char buffer[MAX_BUF + 1];
+	gnutls_psk_client_credentials_t pskcred;
+	/* Need to enable anonymous KX specifically. */
+	const gnutls_datum_t key = { (void *) "DEADBEEF", 8 };
+	const char *hint;
+
+	gnutls_global_set_log_function(tls_log_func);
+	if (debug)
+		gnutls_global_set_log_level(4711);
+
+	side = "client";
+
+	gnutls_psk_allocate_client_credentials(&pskcred);
+	gnutls_psk_set_client_credentials(pskcred, "test", &key,
+					  GNUTLS_PSK_KEY_HEX);
+
+	/* Initialize TLS session
+	 */
+	gnutls_init(&session, GNUTLS_CLIENT);
+
+	/* Use default priorities */
+	ret = gnutls_priority_set_direct(session, prio, NULL);
+	if (ret < 0)
+	  abort();
+
+	/* put the anonymous credentials to the current session
+	 */
+	gnutls_credentials_set(session, GNUTLS_CRD_PSK, pskcred);
+
+	gnutls_transport_set_ptr(session, (gnutls_transport_ptr_t)(long)sd);
+
+	/* Perform the TLS handshake
+	 */
+	ret = gnutls_handshake(session);
+
+	if (ret < 0) {
+		fail("client: Handshake failed\n");
+		gnutls_perror(ret);
+		goto end;
+	} else {
+		if (debug)
+			success("client: Handshake was completed\n");
+	}
+
+	/* check the hint */
+	hint = gnutls_psk_client_get_hint(session);
+	if (hint == NULL || strcmp(hint, "hint") != 0) {
+		fail("client: hint is not the expected: %s\n", gnutls_psk_client_get_hint(session));
+		goto end;
+	}
+
+	gnutls_record_send(session, MSG, strlen(MSG));
+
+	ret = gnutls_record_recv(session, buffer, MAX_BUF);
+	if (ret == 0) {
+		if (debug)
+			success
+			    ("client: Peer has closed the TLS connection\n");
+		goto end;
+	} else if (ret < 0) {
+		fail("client: Error: %s\n", gnutls_strerror(ret));
+		goto end;
+	}
+
+	if (debug) {
+		printf("- Received %d bytes: ", ret);
+		for (ii = 0; ii < ret; ii++) {
+			fputc(buffer[ii], stdout);
+		}
+		fputs("\n", stdout);
+	}
+
+	gnutls_bye(session, GNUTLS_SHUT_RDWR);
+
+      end:
+
+	close(sd);
+
+	gnutls_deinit(session);
+
+	gnutls_psk_free_client_credentials(pskcred);
 }
 
 /* This is a sample TLS 1.0 echo server, for PSK authentication.
  */
 
-#define SA struct sockaddr
 #define MAX_BUF 1024
-#define PORT 5556               /* listen to 5556 port */
 
 /* These are global */
-gnutls_psk_server_credentials_t server_pskcred;
 
-static gnutls_session_t
-initialize_tls_session (void)
+static int
+pskfunc(gnutls_session_t session, const char *username,
+	gnutls_datum_t * key)
 {
-  gnutls_session_t session;
-
-  gnutls_init (&session, GNUTLS_SERVER);
-
-  /* avoid calling all the priority functions, since the defaults
-   * are adequate.
-   */
-  gnutls_priority_set_direct (session, "NORMAL:+PSK", NULL);
-
-  gnutls_credentials_set (session, GNUTLS_CRD_PSK, server_pskcred);
-
-  return session;
+	if (debug)
+		printf("psk: username %s\n", username);
+	key->data = gnutls_malloc(4);
+	key->data[0] = 0xDE;
+	key->data[1] = 0xAD;
+	key->data[2] = 0xBE;
+	key->data[3] = 0xEF;
+	key->size = 4;
+	return 0;
 }
 
-static int
-pskfunc (gnutls_session_t session, const char *username, gnutls_datum_t * key)
+static gnutls_dh_params_t dh_params;
+
+static int generate_dh_params(void)
 {
-  if (debug)
-    printf ("psk: username %s\n", username);
-  key->data = gnutls_malloc (4);
-  key->data[0] = 0xDE;
-  key->data[1] = 0xAD;
-  key->data[2] = 0xBE;
-  key->data[3] = 0xEF;
-  key->size = 4;
-  return 0;
+	const gnutls_datum_t p3 = { (void *) pkcs3, strlen(pkcs3) };
+	/* Generate Diffie-Hellman parameters - for use with DHE
+	 * kx algorithms. These should be discarded and regenerated
+	 * once a day, once a week or once a month. Depending on the
+	 * security requirements.
+	 */
+	gnutls_dh_params_init(&dh_params);
+	return gnutls_dh_params_import_pkcs3(dh_params, &p3,
+					     GNUTLS_X509_FMT_PEM);
 }
 
-int err, listen_sd, i;
-int sd, ret;
-struct sockaddr_in sa_serv;
-struct sockaddr_in sa_cli;
-int client_len;
-char topbuf[512];
+
+static void server(int sd, const char *prio)
+{
+gnutls_psk_server_credentials_t server_pskcred;
+int ret;
 gnutls_session_t session;
 char buffer[MAX_BUF + 1];
-int optval = 1;
 
-static void
-server_start (void)
-{
-  if (debug)
-    success ("Launched...\n");
-
-  /* Socket operations
-   */
-  listen_sd = socket (AF_INET, SOCK_STREAM, 0);
-  if (err == -1)
-    {
-      perror ("socket");
-      fail ("server: socket failed\n");
-      return;
-    }
-
-  memset (&sa_serv, '\0', sizeof (sa_serv));
-  sa_serv.sin_family = AF_INET;
-  sa_serv.sin_addr.s_addr = INADDR_ANY;
-  sa_serv.sin_port = htons (PORT);      /* Server Port number */
-
-  setsockopt (listen_sd, SOL_SOCKET, SO_REUSEADDR, (void *) &optval,
-              sizeof (int));
-
-  err = bind (listen_sd, (SA *) & sa_serv, sizeof (sa_serv));
-  if (err == -1)
-    {
-      perror ("bind");
-      fail ("server: bind failed\n");
-      return;
-    }
-
-  err = listen (listen_sd, 1024);
-  if (err == -1)
-    {
-      perror ("listen");
-      fail ("server: listen failed\n");
-      return;
-    }
-
-  if (debug)
-    success ("server: ready. Listening to port '%d'.\n", PORT);
+	/* this must be called once in the program
+	 */
+	gnutls_global_set_log_function(tls_log_func);
+	if (debug)
+		gnutls_global_set_log_level(4711);
+
+	side = "server";
+
+
+	gnutls_psk_allocate_server_credentials(&server_pskcred);
+	gnutls_psk_set_server_credentials_hint(server_pskcred, "hint");
+	gnutls_psk_set_server_credentials_function(server_pskcred,
+						   pskfunc);
+
+	gnutls_psk_set_server_dh_params(server_pskcred, dh_params);
+
+	gnutls_init(&session, GNUTLS_SERVER);
+
+	/* avoid calling all the priority functions, since the defaults
+	 * are adequate.
+	 */
+	ret = gnutls_priority_set_direct(session, prio, NULL);
+	if (ret < 0)
+	  abort();
+
+	gnutls_credentials_set(session, GNUTLS_CRD_PSK, server_pskcred);
+
+	gnutls_transport_set_ptr(session, (gnutls_transport_ptr_t)(long)sd);
+	ret = gnutls_handshake(session);
+	if (ret < 0) {
+		close(sd);
+		gnutls_deinit(session);
+		fail("server: Handshake has failed (%s)\n\n",
+		     gnutls_strerror(ret));
+		return;
+	}
+	if (debug)
+		success("server: Handshake was completed\n");
+
+	/* see the Getting peer's information example */
+	/* print_info(session); */
+
+	for (;;) {
+		memset(buffer, 0, MAX_BUF + 1);
+		ret = gnutls_record_recv(session, buffer, MAX_BUF);
+
+		if (ret == 0) {
+			if (debug)
+				success
+				    ("server: Peer has closed the GnuTLS connection\n");
+			break;
+		} else if (ret < 0) {
+			fail("server: Received corrupted data(%d). Closing...\n", ret);
+			break;
+		} else if (ret > 0) {
+			/* echo data back to the client
+			 */
+			gnutls_record_send(session, buffer,
+					   strlen(buffer));
+		}
+	}
+	/* do not wait for the peer to close the connection.
+	 */
+	gnutls_bye(session, GNUTLS_SHUT_WR);
+
+	close(sd);
+	gnutls_deinit(session);
+
+	gnutls_psk_free_server_credentials(server_pskcred);
+
+	if (debug)
+		success("server: finished\n");
 }
 
-static void
-server (void)
+static
+void run_test(const char *prio)
 {
-  /* this must be called once in the program
-   */
-  gnutls_global_init ();
-
-  gnutls_psk_allocate_server_credentials (&server_pskcred);
-  gnutls_psk_set_server_credentials_function (server_pskcred, pskfunc);
-
-  client_len = sizeof (sa_cli);
-
-  session = initialize_tls_session ();
-
-  sd = accept (listen_sd, (SA *) & sa_cli, &client_len);
-
-  if (debug)
-    success ("server: connection from %s, port %d\n",
-             inet_ntop (AF_INET, &sa_cli.sin_addr, topbuf,
-                        sizeof (topbuf)), ntohs (sa_cli.sin_port));
-
-  gnutls_transport_set_ptr (session, (gnutls_transport_ptr_t) sd);
-  ret = gnutls_handshake (session);
-  if (ret < 0)
-    {
-      close (sd);
-      gnutls_deinit (session);
-      fail ("server: Handshake has failed (%s)\n\n", gnutls_strerror (ret));
-      return;
-    }
-  if (debug)
-    success ("server: Handshake was completed\n");
-
-  /* see the Getting peer's information example */
-  /* print_info(session); */
-
-  i = 0;
-  for (;;)
-    {
-      memset (buffer, 0, MAX_BUF + 1);
-      ret = gnutls_record_recv (session, buffer, MAX_BUF);
-
-      if (ret == 0)
-        {
-          if (debug)
-            success ("server: Peer has closed the GnuTLS connection\n");
-          break;
-        }
-      else if (ret < 0)
-        {
-          fail ("server: Received corrupted data(%d). Closing...\n", ret);
-          break;
-        }
-      else if (ret > 0)
-        {
-          /* echo data back to the client
-           */
-          gnutls_record_send (session, buffer, strlen (buffer));
-        }
-    }
-  /* do not wait for the peer to close the connection.
-   */
-  gnutls_bye (session, GNUTLS_SHUT_WR);
-
-  close (sd);
-  gnutls_deinit (session);
-
-  close (listen_sd);
-
-  gnutls_psk_free_server_credentials (server_pskcred);
-
-  gnutls_global_deinit ();
-
-  if (debug)
-    success ("server: finished\n");
+	pid_t child;
+	int err;
+	int sockets[2];
+
+	err = socketpair(AF_UNIX, SOCK_STREAM, 0, sockets);
+	if (err == -1) {
+		perror("socketpair");
+		fail("socketpair failed\n");
+		return;
+	}
+
+	child = fork();
+	if (child < 0) {
+		perror("fork");
+		fail("fork");
+		return;
+	}
+
+	if (child) {
+		int status;
+		/* parent */
+		server(sockets[0], prio);
+		wait(&status);
+	} else {
+		client(sockets[1], prio);
+	}
 }
 
-void
-doit (void)
+void doit(void)
 {
-  pid_t child;
-
-  server_start ();
-  if (error_count)
-    return;
-
-  child = fork ();
-  if (child < 0)
-    {
-      perror ("fork");
-      fail ("fork");
-      return;
-    }
-
-  if (child)
-    {
-      int status;
-      /* parent */
-      server ();
-      wait (&status);
-    }
-  else
-    client ();
+	gnutls_global_init();
+	generate_dh_params();
+
+	run_test("NONE:+PSK:+CIPHER-ALL:+COMP-NULL:+SIGN-ALL:+MAC-ALL:+CTYPE-X509:+VERS-TLS-ALL");
+	run_test("NONE:+DHE-PSK:+CIPHER-ALL:+COMP-NULL:+SIGN-ALL:+MAC-ALL:+CTYPE-X509:+VERS-TLS-ALL");
+
+	gnutls_dh_params_deinit(dh_params);
+	gnutls_global_deinit();
 }
+
+#endif				/* _WIN32 */
diff --git a/lib/gnutls_psk.c b/lib/gnutls_psk.c
index 20b9a06..0a62669 100644
--- a/lib/gnutls_psk.c
+++ b/lib/gnutls_psk.c
@@ -157,6 +157,7 @@ error:
 void
 gnutls_psk_free_server_credentials (gnutls_psk_server_credentials_t sc)
 {
+  gnutls_free (sc->hint);
   gnutls_free (sc->password_file);
   gnutls_free (sc);
 }
