diff -up gnutls-2.8.5/lib/gnutls_cipher.c.lucky13 gnutls-2.8.5/lib/gnutls_cipher.c
--- gnutls-2.8.5/lib/gnutls_cipher.c.lucky13	2013-05-27 16:02:32.386988337 +0200
+++ gnutls-2.8.5/lib/gnutls_cipher.c	2013-05-27 17:50:56.794639978 +0200
@@ -417,9 +417,48 @@ _gnutls_compressed2ciphertext (gnutls_se
   return length;
 }
 
-#define DEINIT_MAC(td, ver, algo) \
-          if (algo != GNUTLS_MAC_NULL) \
-            mac_deinit (&td, NULL, ver);
+static void dummy_wait(gnutls_session_t session, gnutls_datum_t* plaintext, 
+                       unsigned pad_failed, unsigned int pad, unsigned total, int ver)
+{
+  /* this hack is only needed on CBC ciphers */
+  if (_gnutls_cipher_is_block (session->security_parameters.read_bulk_cipher_algorithm) == CIPHER_BLOCK)
+    {
+      uint8_t MAC[MAX_HASH_SIZE];
+      unsigned len;
+      digest_hd_st td;
+      int ret;
+
+      ret = mac_init (&td, session->security_parameters.read_mac_algorithm,
+		  session->connection_state.read_mac_secret.data,
+		  session->connection_state.read_mac_secret.size, ver);
+
+      if (ret < 0)
+        return;
+
+      /* force an additional hash compression function evaluation to prevent timing 
+       * attacks that distinguish between wrong-mac + correct pad, from wrong-mac + incorrect pad.
+       */
+      if (pad_failed == 0 && pad > 0) 
+        {
+          len = _gnutls_get_hash_block_len(session->security_parameters.read_mac_algorithm);
+          if (len > 0)
+            {
+              /* This is really specific to the current hash functions.
+               * It should be removed once a protocol fix is in place.
+               */
+	      if ((pad+total) % len > len-9 && total % len <= len-9) 
+	        {
+	          if (len < plaintext->size)
+                    _gnutls_hmac (&td, plaintext->data, len);
+                  else
+                    _gnutls_hmac (&td, plaintext->data, plaintext->size);
+                }
+            }
+        }
+
+      mac_deinit (&td, MAC, ver);
+    }
+}
 
 /* Deciphers the ciphertext packet, and puts the result to compress_data, of compress_size.
  * Returns the actual compressed packet size.
@@ -432,12 +471,14 @@ _gnutls_ciphertext2compressed (gnutls_se
 {
   uint8_t MAC[MAX_HASH_SIZE];
   uint16_t c_length;
-  uint8_t pad;
+  unsigned int pad = 0;
   int length;
-  digest_hd_st td;
   uint16_t blocksize;
-  int ret, i, pad_failed = 0;
+  int ret, i;
+  unsigned int tmp_pad_failed = 0;
+  unsigned int pad_failed = 0;
   uint8_t major, minor;
+  int preamble_size = 11;
   gnutls_protocol_t ver;
   int hash_size =
     _gnutls_hash_get_algo_len (session->security_parameters.
@@ -447,23 +488,13 @@ _gnutls_ciphertext2compressed (gnutls_se
   minor = _gnutls_version_get_minor (ver);
   major = _gnutls_version_get_major (ver);
 
+  if (_gnutls_version_has_variable_padding(ver))
+    preamble_size +=2;
+
   blocksize =
     _gnutls_cipher_get_block_size (session->security_parameters.
 				   read_bulk_cipher_algorithm);
 
-  /* initialize MAC 
-   */
-  ret = mac_init (&td, session->security_parameters.read_mac_algorithm,
-		  session->connection_state.read_mac_secret.data,
-		  session->connection_state.read_mac_secret.size, ver);
-
-  if (ret < 0
-      && session->security_parameters.read_mac_algorithm != GNUTLS_MAC_NULL)
-    {
-      gnutls_assert ();
-      return GNUTLS_E_INTERNAL_ERROR;
-    }
-
   /* actual decryption (inplace)
    */
   switch (_gnutls_cipher_is_block
@@ -476,9 +507,6 @@ _gnutls_ciphertext2compressed (gnutls_se
 				   ciphertext.size)) < 0)
 	{
 	  gnutls_assert ();
-	  DEINIT_MAC(td, ver, session->security_parameters.write_mac_algorithm);
-
-
 	  return ret;
 	}
 
@@ -489,7 +517,6 @@ _gnutls_ciphertext2compressed (gnutls_se
       if ((ciphertext.size < blocksize) || (ciphertext.size % blocksize != 0))
 	{
 	  gnutls_assert ();
-	  DEINIT_MAC(td, ver, session->security_parameters.write_mac_algorithm);
 	  return GNUTLS_E_DECRYPTION_FAILED;
 	}
 
@@ -499,7 +526,6 @@ _gnutls_ciphertext2compressed (gnutls_se
 				   ciphertext.size)) < 0)
 	{
 	  gnutls_assert ();
-	  DEINIT_MAC(td, ver, session->security_parameters.write_mac_algorithm);
 	  return ret;
 	}
 
@@ -512,40 +538,32 @@ _gnutls_ciphertext2compressed (gnutls_se
 	}
 
       if (ciphertext.size < hash_size)
-	{
-	  gnutls_assert ();
-	  DEINIT_MAC(td, ver, session->security_parameters.write_mac_algorithm);
-	  return GNUTLS_E_DECRYPTION_FAILED;
-	}
-      pad = ciphertext.data[ciphertext.size - 1] + 1;	/* pad */
-
-      if ((int) pad > (int) ciphertext.size - hash_size)
-	{
-	  gnutls_assert ();
-	  _gnutls_record_log
-	    ("REC[%p]: Short record length %d > %d - %d (under attack?)\n",
-	     session, pad, ciphertext.size, hash_size);
-	  /* We do not fail here. We check below for the
-	   * the pad_failed. If zero means success.
-	   */
-	  pad_failed = GNUTLS_E_DECRYPTION_FAILED;
-	}
-
-      length = ciphertext.size - hash_size - pad;
-
-      /* Check the pading bytes (TLS 1.x)
+        {
+          gnutls_assert ();
+          return GNUTLS_E_DECRYPTION_FAILED;
+        }
+      pad = ciphertext.data[ciphertext.size - 1];   /* pad */
+
+      /* Check the pading bytes (TLS 1.x). 
+       * Note that we access all 256 bytes of ciphertext for padding check
+       * because there is a timing channel in that memory access (in certain CPUs).
        */
-      if (_gnutls_version_has_variable_padding(ver) && pad_failed == 0)
-	for (i = 2; i < pad; i++)
-	  {
-	    if (ciphertext.data[ciphertext.size - i] !=
-		ciphertext.data[ciphertext.size - 1])
-	      pad_failed = GNUTLS_E_DECRYPTION_FAILED;
-	  }
+      if (_gnutls_version_has_variable_padding (ver))
+        for (i = 2; i <= MIN(256, ciphertext.size); i++)
+          {
+            tmp_pad_failed |= (ciphertext.data[ciphertext.size - i] != pad);
+            pad_failed |= ((i <= (1+pad)) & (tmp_pad_failed));
+          }
+
+      pad_failed |= 1+pad > ((int) ciphertext.size - hash_size);    
+
+      if (pad_failed)
+        pad = 0;
+      length = ciphertext.size - hash_size - pad - 1;
+
       break;
     default:
       gnutls_assert ();
-      DEINIT_MAC(td, ver, session->security_parameters.write_mac_algorithm);
       return GNUTLS_E_INTERNAL_ERROR;
     }
 
@@ -558,6 +576,18 @@ _gnutls_ciphertext2compressed (gnutls_se
    */
   if (session->security_parameters.read_mac_algorithm != GNUTLS_MAC_NULL)
     {
+      digest_hd_st td;
+
+      ret = mac_init (&td, session->security_parameters.read_mac_algorithm,
+		  session->connection_state.read_mac_secret.data,
+		  session->connection_state.read_mac_secret.size, ver);
+
+      if (ret < 0)
+        {
+          gnutls_assert ();
+          return GNUTLS_E_INTERNAL_ERROR;
+        }
+
       _gnutls_hmac (&td,
 		    UINT64DATA (session->connection_state.
 				read_sequence_number), 8);
@@ -576,16 +606,14 @@ _gnutls_ciphertext2compressed (gnutls_se
       mac_deinit (&td, MAC, ver);
     }
 
-  /* This one was introduced to avoid a timing attack against the TLS
-   * 1.0 protocol.
-   */
-  if (pad_failed != 0)
-    return pad_failed;
-
   /* HMAC was not the same. 
    */
-  if (memcmp (MAC, &ciphertext.data[length], hash_size) != 0)
+  if (memcmp (MAC, &ciphertext.data[length], hash_size) != 0 || pad_failed != 0)
     {
+      gnutls_datum_t compressed = {compress_data, compress_size};
+      /* HMAC was not the same. */
+      dummy_wait(session, &compressed, pad_failed, pad, length+preamble_size, ver);
+
       gnutls_assert ();
       return GNUTLS_E_DECRYPTION_FAILED;
     }
diff -up gnutls-2.8.5/lib/gnutls_hash_int.h.lucky13 gnutls-2.8.5/lib/gnutls_hash_int.h
--- gnutls-2.8.5/lib/gnutls_hash_int.h.lucky13	2013-05-27 16:02:32.406988765 +0200
+++ gnutls-2.8.5/lib/gnutls_hash_int.h	2013-05-27 16:02:32.467990072 +0200
@@ -93,4 +93,25 @@ void _gnutls_mac_deinit_ssl3_handshake (
 
 int _gnutls_hash_copy (digest_hd_st* dst_handle, digest_hd_st * src_handle);
 
+/* We shouldn't need to know that, but a work-around in decoding
+ * TLS record padding requires that.
+ */
+inline static size_t
+_gnutls_get_hash_block_len (gnutls_digest_algorithm_t algo)
+{
+  switch (algo)
+    {
+    case GNUTLS_DIG_MD5:
+    case GNUTLS_DIG_SHA1:
+    case GNUTLS_DIG_RMD160:
+    case GNUTLS_DIG_SHA256:
+    case GNUTLS_DIG_SHA384:
+    case GNUTLS_DIG_SHA512:
+    case GNUTLS_DIG_SHA224:
+      return 64;
+    default:
+      return 0;
+    }
+}
+
 #endif /* GNUTLS_HASH_INT_H */
