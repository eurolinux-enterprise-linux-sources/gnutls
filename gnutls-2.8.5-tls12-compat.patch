diff -up gnutls-2.8.5/doc/examples/ex-cert-select.c.tls12 gnutls-2.8.5/doc/examples/ex-cert-select.c
--- gnutls-2.8.5/doc/examples/ex-cert-select.c.tls12	2009-06-02 20:59:32.000000000 +0200
+++ gnutls-2.8.5/doc/examples/ex-cert-select.c	2012-05-03 14:46:45.393866368 +0200
@@ -259,6 +259,44 @@ cert_callback (gnutls_session_t session,
   type = gnutls_certificate_type_get (session);
   if (type == GNUTLS_CRT_X509)
     {
+      /* check if the certificate we are sending is signed
+       * with an algorithm that the server accepts */
+      gnutls_sign_algorithm_t cert_algo, req_algo;
+      int i, match = 0;
+
+      ret = gnutls_x509_crt_get_signature_algorithm(crt);
+      if (ret < 0)
+        {
+          /* error reading signature algorithm 
+           */
+          return -1;
+        }
+      cert_algo = ret;
+    
+      i=0;
+      do {
+        ret = gnutls_sign_algorithm_get_requested(session, i, &req_algo);
+        if (ret >= 0 && cert_algo == req_algo)
+          {
+            match = 1;
+            break;
+          }
+          
+         /* server has not requested anything specific */
+        if (i==0 && ret == GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE)
+          {
+            match = 1;
+            break;
+          }
+        i++;
+      } while(ret >= 0);
+      
+      if (match == 0)
+        {
+          printf("- Could not find a suitable certificate to send to server\n");
+          return -1;
+        }
+
       st->type = type;
       st->ncerts = 1;
 
diff -up gnutls-2.8.5/doc/gnutls-api.texi.tls12 gnutls-2.8.5/doc/gnutls-api.texi
--- gnutls-2.8.5/doc/gnutls-api.texi.tls12	2012-10-29 18:27:46.000000000 +0100
+++ gnutls-2.8.5/doc/gnutls-api.texi	2012-10-29 18:29:45.027193621 +0100
@@ -3642,6 +3642,31 @@ Convert a @code{gnutls_sign_algorithm_t}
 algorithm, or @code{NULL}.
 @end deftypefun
 
+@subheading gnutls_sign_algorithm_get_requested
+@anchor{gnutls_sign_algorithm_get_requested}
+@deftypefun {int} {gnutls_sign_algorithm_get_requested} (gnutls_session_t @var{session}, size_t @var{indx}, gnutls_sign_algorithm_t * @var{algo})
+@var{session}: is a @code{gnutls_session_t} structure.
+
+@var{indx}: is an index of the signature algorithm to return
+
+@var{algo}: the returned certificate type will be stored there
+
+Returns the signature algorithm specified by index that was
+requested by the peer. If the specified index has no data available
+this function returns @code{GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE}.  If
+the negotiated TLS version does not support signature algorithms
+then @code{GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE} will be returned even
+for the first index.  The first index is 0.
+
+This function is useful in the certificate callback functions
+to assist in selecting the correct certificate.
+
+@strong{Returns:} On success, @code{GNUTLS_E_SUCCESS} (0) is returned, otherwise
+an error code is returned.
+
+@strong{Since:} 2.10.0
+@end deftypefun
+
 @subheading gnutls_sign_callback_get
 @anchor{gnutls_sign_callback_get}
 @deftypefun {gnutls_sign_func} {gnutls_sign_callback_get} (gnutls_session_t @var{session}, void ** @var{userdata})
diff -up gnutls-2.8.5/doc/gnutls.texi.tls12 gnutls-2.8.5/doc/gnutls.texi
--- gnutls-2.8.5/doc/gnutls.texi.tls12	2012-04-27 17:16:04.297094267 +0200
+++ gnutls-2.8.5/doc/gnutls.texi	2012-05-03 14:57:43.914897493 +0200
@@ -1376,6 +1376,11 @@ callback can be set using the functions:
 
 @end itemize
 
+Clients and servers that will select certificates using callback
+functions should select a certificate according the peer's signature
+algorithm preferences. To get those preferences use
+@ref{gnutls_sign_algorithm_get_requested}.
+
 Certificate verification is possible by loading the trusted
 authorities into the credentials structure by using
 @ref{gnutls_certificate_set_x509_trust_file} or
diff -up gnutls-2.8.5/doc/manpages/gnutls_sign_algorithm_get_requested.3.tls12 gnutls-2.8.5/doc/manpages/gnutls_sign_algorithm_get_requested.3
--- gnutls-2.8.5/doc/manpages/gnutls_sign_algorithm_get_requested.3.tls12	2012-05-03 14:43:27.185460958 +0200
+++ gnutls-2.8.5/doc/manpages/gnutls_sign_algorithm_get_requested.3	2010-09-30 08:58:10.000000000 +0200
@@ -0,0 +1,52 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by gdoc.
+.TH "gnutls_sign_algorithm_get_requested" 3 "2.10.2" "gnutls" "gnutls"
+.SH NAME
+gnutls_sign_algorithm_get_requested \- API function
+.SH SYNOPSIS
+.B #include <gnutls/gnutls.h>
+.sp
+.BI "int gnutls_sign_algorithm_get_requested(gnutls_session_t " session ", size_t " indx ", gnutls_sign_algorithm_t * " algo ");"
+.SH ARGUMENTS
+.IP "gnutls_session_t session" 12
+is a \fBgnutls_session_t\fP structure.
+.IP "size_t indx" 12
+is an index of the signature algorithm to return
+.IP "gnutls_sign_algorithm_t * algo" 12
+the returned certificate type will be stored there
+.SH "DESCRIPTION"
+Returns the signature algorithm specified by index that was
+requested by the peer. If the specified index has no data available
+this function returns \fBGNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE\fP.  If
+the negotiated TLS version does not support signature algorithms
+then \fBGNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE\fP will be returned even
+for the first index.  The first index is 0.
+
+This function is useful in the certificate callback functions
+to assist in selecting the correct certificate.
+.SH "RETURNS"
+On success, \fBGNUTLS_E_SUCCESS\fP (0) is returned, otherwise
+an error code is returned.
+.SH "SINCE"
+2.10.0
+.SH "REPORTING BUGS"
+Report bugs to <bug-gnutls@gnu.org>.
+GnuTLS home page: http://www.gnu.org/software/gnutls/
+General help using GNU software: http://www.gnu.org/gethelp/
+.SH COPYRIGHT
+Copyright \(co 2008 Free Software Foundation.
+.br
+Copying and distribution of this file, with or without modification,
+are permitted in any medium without royalty provided the copyright
+notice and this notice are preserved.
+.SH "SEE ALSO"
+The full documentation for
+.B gnutls
+is maintained as a Texinfo manual.  If the
+.B info
+and
+.B gnutls
+programs are properly installed at your site, the command
+.IP
+.B info gnutls
+.PP
+should give you access to the complete manual.
diff -up gnutls-2.8.5/doc/manpages/Makefile.in.tls12 gnutls-2.8.5/doc/manpages/Makefile.in
--- gnutls-2.8.5/doc/manpages/Makefile.in.tls12	2012-04-27 17:16:04.000000000 +0200
+++ gnutls-2.8.5/doc/manpages/Makefile.in	2012-05-03 14:44:39.976078813 +0200
@@ -695,7 +695,7 @@ APIMANS = gnutls_crypto_single_cipher_re
 	gnutls_protocol_list.3 gnutls_cipher_suite_get_name.3 \
 	gnutls_cipher_suite_info.3 gnutls_certificate_type_get_name.3 \
 	gnutls_certificate_type_get_id.3 \
-	gnutls_certificate_type_list.3 \
+	gnutls_certificate_type_list.3 gnutls_sign_algorithm_get_requested.3 \
 	gnutls_sign_algorithm_get_name.3 gnutls_sign_list.3 \
 	gnutls_sign_get_id.3 gnutls_sign_get_name.3 \
 	gnutls_pk_algorithm_get_name.3 gnutls_pk_list.3 \
diff -up gnutls-2.8.5/lib/auth_cert.c.tls12 gnutls-2.8.5/lib/auth_cert.c
--- gnutls-2.8.5/lib/auth_cert.c.tls12	2009-07-22 20:26:40.000000000 +0200
+++ gnutls-2.8.5/lib/auth_cert.c	2012-04-30 16:48:28.658134099 +0200
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation
+ * Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 Free Software Foundation
  *
  * Author: Nikos Mavrogiannopoulos
  *
@@ -112,6 +112,8 @@ _gnutls_copy_certificate_auth_info (cert
   info->ncerts = ncerts;
 
   info->cert_type = cert[0].cert_type;
+  info->sign_algo = cert[0].sign_algo;
+
 #ifdef ENABLE_OPENPGP
   if (cert[0].cert_type == GNUTLS_CRT_OPENPGP)
     {
@@ -1023,6 +1025,14 @@ _gnutls_proc_x509_server_certificate (gn
 	  gnutls_assert ();
 	  goto cleanup;
 	}
+      
+      /* check if signature algorithm is supported */
+      ret = _gnutls_session_sign_algo_enabled(session, peer_certificate_list[j].sign_algo);
+      if (ret < 0)
+        {
+          gnutls_assert();
+          goto cleanup;
+        }
 
       p += len;
     }
@@ -1352,16 +1362,22 @@ _gnutls_proc_cert_cert_req (gnutls_sessi
       return GNUTLS_E_UNKNOWN_PK_ALGORITHM;
     }
 
-  if (ver == GNUTLS_TLS1_2)
+  if (_gnutls_version_has_selectable_sighash(ver))
     {
       /* read supported hashes */
       int hash_num;
-      DECR_LEN (dsize, 1);
+      DECR_LEN (dsize, 2);
+      hash_num = _gnutls_read_uint16 (p);
+      p += 2;
+      DECR_LEN (dsize, hash_num);
 
-      hash_num = p[0] & 0xFF;
-      p++;
+      ret = _gnutls_sign_algorithm_parse_data( session, p, hash_num);
+      if (ret < 0)
+        {
+          gnutls_assert();
+          return ret;
+        }
 
-      DECR_LEN (dsize, hash_num);
       p += hash_num;
     }
 
@@ -1405,6 +1421,10 @@ _gnutls_gen_cert_client_cert_vrfy (gnutl
   gnutls_privkey *apr_pkey;
   int apr_cert_list_length, size;
   gnutls_datum_t signature;
+  int total_data;
+  opaque* p;
+  gnutls_sign_algorithm_t sign_algo;
+  gnutls_protocol_t ver = gnutls_protocol_get_version (session);
 
   *data = NULL;
 
@@ -1420,33 +1440,55 @@ _gnutls_gen_cert_client_cert_vrfy (gnutl
   if (apr_cert_list_length > 0)
     {
       if ((ret =
-	   _gnutls_tls_sign_hdata (session,
+	   _gnutls_handshake_sign_cert_vrfy (session,
 				   &apr_cert_list[0],
 				   apr_pkey, &signature)) < 0)
 	{
 	  gnutls_assert ();
 	  return ret;
 	}
+	sign_algo = ret;
     }
   else
     {
       return 0;
     }
 
-  *data = gnutls_malloc (signature.size + 2);
+  total_data = signature.size + 2;
+
+  /* add hash and signature algorithms */
+  if (_gnutls_version_has_selectable_sighash(ver))
+    {
+      total_data+=2;
+    }
+
+  *data = gnutls_malloc (total_data);
   if (*data == NULL)
     {
       _gnutls_free_datum (&signature);
       return GNUTLS_E_MEMORY_ERROR;
     }
+
+  p = *data;
+  if (_gnutls_version_has_selectable_sighash(ver))
+    {
+      sign_algorithm_st aid;
+      /* error checking is not needed here since we have used those algorithms */
+      aid = _gnutls_sign_to_tls_aid(sign_algo);
+      p[0] = aid.hash_algorithm;
+      p[1] = aid.sign_algorithm;
+      p+=2;
+    }
+
   size = signature.size;
-  _gnutls_write_uint16 (size, *data);
+  _gnutls_write_uint16 (size, p);
 
-  memcpy (&(*data)[2], signature.data, size);
+  p+=2;
+  memcpy (p, signature.data, size);
 
   _gnutls_free_datum (&signature);
 
-  return size + 2;
+  return total_data;
 }
 
 int
@@ -1459,6 +1501,8 @@ _gnutls_proc_cert_client_cert_vrfy (gnut
   gnutls_datum_t sig;
   cert_auth_info_t info = _gnutls_get_auth_info (session);
   gnutls_cert peer_cert;
+  gnutls_sign_algorithm_t sign_algo = GNUTLS_SIGN_UNKNOWN;
+  gnutls_protocol_t ver = gnutls_protocol_get_version (session);
 
   if (info == NULL || info->ncerts == 0)
     {
@@ -1467,6 +1511,30 @@ _gnutls_proc_cert_client_cert_vrfy (gnut
       return GNUTLS_E_INTERNAL_ERROR;
     }
 
+  if (_gnutls_version_has_selectable_sighash(ver))
+    {
+    sign_algorithm_st aid;
+
+      DECR_LEN (dsize, 2);
+      aid.hash_algorithm = pdata[0];
+      aid.sign_algorithm = pdata[1];
+      
+      sign_algo = _gnutls_tls_aid_to_sign(&aid);
+      if (sign_algo == GNUTLS_PK_UNKNOWN)
+        {
+          gnutls_assert();
+          return GNUTLS_E_UNSUPPORTED_SIGNATURE_ALGORITHM;
+        }
+      pdata+=2;
+    }
+
+  ret = _gnutls_session_sign_algo_enabled (session, sign_algo);
+  if (ret < 0)
+    {
+      gnutls_assert();
+      return GNUTLS_E_UNSUPPORTED_SIGNATURE_ALGORITHM;
+    }
+
   DECR_LEN (dsize, 2);
   size = _gnutls_read_uint16 (pdata);
   pdata += 2;
@@ -1486,7 +1554,7 @@ _gnutls_proc_cert_client_cert_vrfy (gnut
       return ret;
     }
 
-  if ((ret = _gnutls_verify_sig_hdata (session, &peer_cert, &sig)) < 0)
+  if ((ret = _gnutls_handshake_verify_cert_vrfy (session, &peer_cert, &sig, sign_algo)) < 0)
     {
       gnutls_assert ();
       _gnutls_gcert_deinit (&peer_cert);
@@ -1502,9 +1570,10 @@ int
 _gnutls_gen_cert_server_cert_req (gnutls_session_t session, opaque ** data)
 {
   gnutls_certificate_credentials_t cred;
-  int size;
+  int size, ret;
   opaque *pdata;
   gnutls_protocol_t ver = gnutls_protocol_get_version (session);
+  const int signalgosize = 2+MAX_SIGNATURE_ALGORITHMS*2;
 
   /* Now we need to generate the RDN sequence. This is
    * already in the CERTIFICATE_CRED structure, to improve
@@ -1526,10 +1595,10 @@ _gnutls_gen_cert_server_cert_req (gnutls
       session->internals.ignore_rdn_sequence == 0)
     size += cred->x509_rdn_sequence.size;
 
-  if (ver == GNUTLS_TLS1_2)
-    /* Need at least one byte to announce the number of supported hash
+  if (_gnutls_version_has_selectable_sighash(ver))
+    /* Need two bytes to announce the number of supported hash
        functions (see below).  */
-    size += 1;
+    size += signalgosize;
 
   (*data) = gnutls_malloc (size);
   pdata = (*data);
@@ -1546,11 +1615,18 @@ _gnutls_gen_cert_server_cert_req (gnutls
   pdata[2] = DSA_SIGN;		/* only these for now */
   pdata += CERTTYPE_SIZE;
 
-  if (ver == GNUTLS_TLS1_2)
+  if (_gnutls_version_has_selectable_sighash(ver))
     {
-      /* Supported hashes (nothing for now -- FIXME). */
-      *pdata = 0;
-      pdata++;
+      ret = _gnutls_sign_algorithm_write_params(session, pdata, signalgosize);
+      if (ret < 0)
+        {
+          gnutls_assert();
+          return ret;
+        }
+      
+      /* recalculate size */
+      size=size-signalgosize+ret;
+      pdata += ret;
     }
 
   if (session->security_parameters.cert_type == GNUTLS_CRT_X509 &&
@@ -1846,10 +1922,10 @@ _gnutls_server_select_cert (gnutls_sessi
       if (requested_algo == GNUTLS_PK_ANY ||
 	  requested_algo == cred->cert_list[i][0].subject_pk_algorithm)
 	{
-	  /* if cert type matches 
+	  /* if cert type and signature algorithm matches 
 	   */
 	  if (session->security_parameters.cert_type ==
-	      cred->cert_list[i][0].cert_type)
+	      cred->cert_list[i][0].cert_type && _gnutls_session_sign_algo_requested(session, cred->cert_list[i][0].sign_algo) == 0)
 	    {
 	      idx = i;
 	      break;
diff -up gnutls-2.8.5/lib/auth_cert.h.tls12 gnutls-2.8.5/lib/auth_cert.h
--- gnutls-2.8.5/lib/auth_cert.h.tls12	2009-07-29 20:59:36.000000000 +0200
+++ gnutls-2.8.5/lib/auth_cert.h	2012-04-30 15:36:14.871288476 +0200
@@ -117,6 +117,7 @@ typedef struct cert_auth_info_st
   unsigned int ncerts;		/* holds the size of the list above */
 
   gnutls_certificate_type_t cert_type;
+  gnutls_sign_algorithm_t sign_algo;
 #ifdef ENABLE_OPENPGP
   int use_subkey;
   gnutls_openpgp_keyid_t subkey_id;
diff -up gnutls-2.8.5/lib/auth_dhe.c.tls12 gnutls-2.8.5/lib/auth_dhe.c
--- gnutls-2.8.5/lib/auth_dhe.c.tls12	2009-06-02 20:59:32.000000000 +0200
+++ gnutls-2.8.5/lib/auth_dhe.c	2012-04-30 16:48:28.659134121 +0200
@@ -34,6 +34,7 @@
 #include "gnutls_num.h"
 #include "gnutls_sig.h"
 #include <gnutls_datum.h>
+#include <gnutls_algorithms.h>
 #include <auth_cert.h>
 #include <gnutls_x509.h>
 #include <gnutls_state.h>
@@ -90,6 +91,8 @@ gen_dhe_server_kx (gnutls_session_t sess
   gnutls_datum_t signature, ddata;
   gnutls_certificate_credentials_t cred;
   gnutls_dh_params_t dh_params;
+  gnutls_sign_algorithm_t sign_algo;
+  gnutls_protocol_t ver = gnutls_protocol_get_version (session);
 
   cred = (gnutls_certificate_credentials_t)
     _gnutls_get_cred (session->key, GNUTLS_CRD_CERTIFICATE, NULL);
@@ -145,8 +148,9 @@ gen_dhe_server_kx (gnutls_session_t sess
   if (apr_cert_list_length > 0)
     {
       if ((ret =
-	   _gnutls_tls_sign_params (session, &apr_cert_list[0],
-				    apr_pkey, &ddata, &signature)) < 0)
+	   _gnutls_handshake_sign_data (session, &apr_cert_list[0],
+				    apr_pkey, &ddata, &signature,
+				    &sign_algo)) < 0)
 	{
 	  gnutls_assert ();
 	  gnutls_free (*data);
@@ -159,7 +163,7 @@ gen_dhe_server_kx (gnutls_session_t sess
       return data_size;		/* do not put a signature - ILLEGAL! */
     }
 
-  *data = gnutls_realloc_fast (*data, data_size + signature.size + 2);
+  *data = gnutls_realloc_fast (*data, data_size + signature.size + 4);
   if (*data == NULL)
     {
       _gnutls_free_datum (&signature);
@@ -167,6 +171,22 @@ gen_dhe_server_kx (gnutls_session_t sess
       return GNUTLS_E_MEMORY_ERROR;
     }
 
+  if (_gnutls_version_has_selectable_sighash (ver))
+    {
+      sign_algorithm_st aid;
+
+      if (sign_algo == GNUTLS_SIGN_UNKNOWN)
+	{
+	  _gnutls_free_datum (&signature);
+	  gnutls_assert ();
+	  return GNUTLS_E_UNKNOWN_PK_ALGORITHM;
+	}
+
+      aid = _gnutls_sign_to_tls_aid (sign_algo);
+      (*data)[data_size++] = aid.hash_algorithm;
+      (*data)[data_size++] = aid.sign_algorithm;
+    }
+
   _gnutls_write_datum16 (&(*data)[data_size], signature);
   data_size += signature.size + 2;
 
@@ -180,11 +200,14 @@ proc_dhe_server_kx (gnutls_session_t ses
 		    size_t _data_size)
 {
   int sigsize;
+  opaque *sigdata;
   gnutls_datum_t vparams, signature;
   int ret;
   cert_auth_info_t info = _gnutls_get_auth_info (session);
   ssize_t data_size = _data_size;
   gnutls_cert peer_cert;
+  gnutls_sign_algorithm_t sign_algo = GNUTLS_SIGN_UNKNOWN;
+  gnutls_protocol_t ver = gnutls_protocol_get_version (session);
 
   if (info == NULL || info->ncerts == 0)
     {
@@ -205,11 +228,28 @@ proc_dhe_server_kx (gnutls_session_t ses
   vparams.size = ret;
   vparams.data = data;
 
+  sigdata = &data[vparams.size];
+  if (_gnutls_version_has_selectable_sighash (ver))
+    {
+      sign_algorithm_st aid;
+
+      DECR_LEN(data_size, 1);
+      aid.hash_algorithm = *sigdata++;
+      DECR_LEN(data_size, 1);
+      aid.sign_algorithm = *sigdata++;
+      sign_algo = _gnutls_tls_aid_to_sign (&aid);
+      if (sign_algo == GNUTLS_SIGN_UNKNOWN)
+	{
+	  gnutls_assert ();
+	  return GNUTLS_E_UNSUPPORTED_SIGNATURE_ALGORITHM;
+	}
+    }
   DECR_LEN (data_size, 2);
-  sigsize = _gnutls_read_uint16 (&data[vparams.size]);
+  sigsize = _gnutls_read_uint16 (sigdata);
+  sigdata += 2;
 
   DECR_LEN (data_size, sigsize);
-  signature.data = &data[vparams.size + 2];
+  signature.data = sigdata;
   signature.size = sigsize;
 
   if ((ret =
@@ -221,7 +261,8 @@ proc_dhe_server_kx (gnutls_session_t ses
       return ret;
     }
 
-  ret = _gnutls_verify_sig_params (session, &peer_cert, &vparams, &signature);
+  ret = _gnutls_handshake_verify_data (session, &peer_cert, &vparams, &signature,
+				   sign_algo);
 
   _gnutls_gcert_deinit (&peer_cert);
   if (ret < 0)
diff -up gnutls-2.8.5/lib/auth_rsa_export.c.tls12 gnutls-2.8.5/lib/auth_rsa_export.c
--- gnutls-2.8.5/lib/auth_rsa_export.c.tls12	2009-06-02 20:59:32.000000000 +0200
+++ gnutls-2.8.5/lib/auth_rsa_export.c	2012-04-30 16:36:33.591239999 +0200
@@ -78,6 +78,7 @@ gen_rsa_export_server_kx (gnutls_session
   gnutls_datum_t signature, ddata;
   cert_auth_info_t info;
   gnutls_certificate_credentials_t cred;
+  gnutls_sign_algorithm_t sign_algo;
 
   cred = (gnutls_certificate_credentials_t)
     _gnutls_get_cred (session->key, GNUTLS_CRD_CERTIFICATE, NULL);
@@ -155,8 +156,9 @@ gen_rsa_export_server_kx (gnutls_session
   if (apr_cert_list_length > 0)
     {
       if ((ret =
-	   _gnutls_tls_sign_params (session, &apr_cert_list[0],
-				    apr_pkey, &ddata, &signature)) < 0)
+	   _gnutls_handshake_sign_data (session, &apr_cert_list[0],
+				    apr_pkey, &ddata, &signature,
+				    &sign_algo)) < 0)
 	{
 	  gnutls_assert ();
 	  gnutls_free (*data);
@@ -310,7 +312,8 @@ proc_rsa_export_server_kx (gnutls_sessio
       return ret;
     }
 
-  ret = _gnutls_verify_sig_params (session, &peer_cert, &vparams, &signature);
+  ret = _gnutls_handshake_verify_data (session, &peer_cert, &vparams, &signature,
+				   GNUTLS_SIGN_UNKNOWN);
 
   _gnutls_gcert_deinit (&peer_cert);
   if (ret < 0)
diff -up gnutls-2.8.5/lib/ext_cert_type.c.tls12 gnutls-2.8.5/lib/ext_cert_type.c
--- gnutls-2.8.5/lib/ext_cert_type.c.tls12	2009-06-02 20:59:32.000000000 +0200
+++ gnutls-2.8.5/lib/ext_cert_type.c	2012-04-30 16:05:07.902139635 +0200
@@ -88,6 +88,7 @@ _gnutls_cert_type_recv_params (gnutls_se
 	{
 	  uint8_t len;
 
+	  DECR_LEN (data_size, 1);
 	  len = data[0];
 	  DECR_LEN (data_size, len);
 
@@ -241,3 +242,4 @@ _gnutls_cert_type2num (int cert_type)
     }
 
 }
+
diff -up gnutls-2.8.5/lib/ext_signature.c.tls12 gnutls-2.8.5/lib/ext_signature.c
--- gnutls-2.8.5/lib/ext_signature.c.tls12	2012-04-30 15:36:14.872288498 +0200
+++ gnutls-2.8.5/lib/ext_signature.c	2012-04-30 16:52:08.387020821 +0200
@@ -0,0 +1,327 @@
+/*
+ * Copyright (C) 2002, 2003, 2004, 2005, 2009 Free Software Foundation
+ *
+ * Author: Nikos Mavrogiannopoulos
+ *
+ * This file is part of GNUTLS.
+ *
+ * The GNUTLS library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public License
+ * as published by the Free Software Foundation; either version 2.1 of
+ * the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
+ * USA
+ *
+ */
+
+/* This file contains the code the Certificate Type TLS extension.
+ * This extension is currently gnutls specific.
+ */
+
+#include "gnutls_int.h"
+#include "gnutls_errors.h"
+#include "gnutls_num.h"
+#include <ext_signature.h>
+#include <gnutls_state.h>
+#include <gnutls_num.h>
+#include <gnutls_algorithms.h>
+
+/* generates a SignatureAndHashAlgorithm structure with length as prefix
+ * by using the setup priorities.
+ */
+int
+_gnutls_sign_algorithm_write_params (gnutls_session_t session, opaque * data,
+				     size_t max_data_size)
+{
+  opaque *p = data;
+  int len, i, j;
+  sign_algorithm_st aid;
+
+  len = session->internals.priorities.sign_algo.algorithms * 2;
+  if (max_data_size < len + 2)
+    {
+      gnutls_assert ();
+      return GNUTLS_E_SHORT_MEMORY_BUFFER;
+    }
+
+  _gnutls_write_uint16 (len, p);
+  p += 2;
+
+  for (i = j = 0; i < len; i += 2, j++)
+    {
+      aid =
+	_gnutls_sign_to_tls_aid (session->internals.priorities.sign_algo.
+				 priority[j]);
+      *p = aid.hash_algorithm;
+      p++;
+      *p = aid.sign_algorithm;
+      p++;
+
+    }
+  return len + 2;
+}
+
+/* Parses the Signature Algorithm structure and stores data into
+ * session->security_parameters.extensions.
+ */
+int
+_gnutls_sign_algorithm_parse_data (gnutls_session_t session,
+				   const opaque * data, size_t data_size)
+{
+  int sig, i;
+
+  session->security_parameters.extensions.sign_algorithms_size = 0;
+
+  for (i = 0; i < data_size; i += 2)
+    {
+      sign_algorithm_st aid;
+
+      aid.hash_algorithm = data[i];
+      aid.sign_algorithm = data[i + 1];
+
+      sig = _gnutls_tls_aid_to_sign (&aid);
+      if (sig != GNUTLS_SIGN_UNKNOWN)
+	{
+	  session->security_parameters.
+	    extensions.sign_algorithms[session->security_parameters.
+				       extensions.
+				       sign_algorithms_size++] = sig;
+	  if (session->security_parameters.extensions.sign_algorithms_size ==
+	      MAX_SIGNATURE_ALGORITHMS)
+	    break;
+	}
+    }
+
+  return 0;
+}
+
+/*
+ * In case of a server: if a SIGNATURE_ALGORITHMS extension type is
+ * received then it stores into the session security parameters the
+ * new value.
+ *
+ * In case of a client: If a signature_algorithms have been specified
+ * then it is an error;
+ */
+
+int
+_gnutls_signature_algorithm_recv_params (gnutls_session_t session,
+					 const opaque * data,
+					 size_t _data_size)
+{
+  ssize_t data_size = _data_size;
+  int ret;
+
+  if (session->security_parameters.entity == GNUTLS_CLIENT)
+    {
+      /* nothing for now */
+      gnutls_assert ();
+      /* Although TLS 1.2 mandates that we must not accept reply
+       * to this message, there are good reasons to just ignore it. Check
+       * http://www.ietf.org/mail-archive/web/tls/current/msg03880.html
+       */
+      /* return GNUTLS_E_UNEXPECTED_PACKET; */
+    }
+  else
+    {
+      /* SERVER SIDE - we must check if the sent cert type is the right one
+       */
+      if (data_size > 2)
+	{
+	  uint16_t len;
+
+
+	  DECR_LEN (data_size, 2);
+	  len = _gnutls_read_uint16 (data);
+	  DECR_LEN (data_size, len);
+
+	  ret = _gnutls_sign_algorithm_parse_data (session, data + 2, len);
+	  if (ret < 0)
+	    {
+	      gnutls_assert ();
+	      return ret;
+	    }
+	}
+    }
+
+  return 0;
+}
+
+/* returns data_size or a negative number on failure
+ */
+int
+_gnutls_signature_algorithm_send_params (gnutls_session_t session,
+					 opaque * data, size_t data_size)
+{
+  int ret;
+  gnutls_protocol_t ver = gnutls_protocol_get_version (session);
+
+  /* this function sends the client extension data */
+  if (session->security_parameters.entity == GNUTLS_CLIENT
+      && _gnutls_version_has_selectable_sighash (ver))
+    {
+      if (session->internals.priorities.sign_algo.algorithms > 0)
+	{
+	  ret =
+	    _gnutls_sign_algorithm_write_params (session, data, data_size);
+	  if (ret < 0)
+	    {
+	      gnutls_assert ();
+	      return ret;
+	    }
+	  return ret;
+	}
+    }
+
+  /* if we are here it means we don't send the extension */
+  return 0;
+}
+
+/* Returns a requested by the peer signature algorithm that
+ * matches the given public key algorithm. Index can be increased
+ * to return the second choice etc.
+ */
+gnutls_sign_algorithm_t
+_gnutls_session_get_sign_algo (gnutls_session_t session,
+			       gnutls_pk_algorithm_t pk,
+			       gnutls_digest_algorithm_t * hash)
+{
+  unsigned i;
+  gnutls_protocol_t ver = gnutls_protocol_get_version (session);
+
+
+  if (!_gnutls_version_has_selectable_sighash (ver)
+      || session->security_parameters.extensions.sign_algorithms_size == 0)
+    /* none set, allow all */
+    {
+      *hash = GNUTLS_DIG_SHA1;
+      return _gnutls_x509_pk_to_sign (pk, *hash);
+    }
+
+  for (i = 0;
+       i < session->security_parameters.extensions.sign_algorithms_size; i++)
+    {
+      if (_gnutls_sign_get_pk_algorithm
+	  (session->security_parameters.extensions.sign_algorithms[i]) == pk)
+	{
+	  *hash =
+	    _gnutls_sign_get_hash_algorithm (session->
+					     security_parameters.extensions.
+					     sign_algorithms[i]);
+	  return session->security_parameters.extensions.sign_algorithms[i];
+	}
+    }
+
+  return GNUTLS_SIGN_UNKNOWN;
+}
+
+
+/* Check if the given signature algorithm is accepted by
+ * the peer. Returns 0 on success or a negative value
+ * on error.
+ */
+int
+_gnutls_session_sign_algo_requested (gnutls_session_t session,
+				     gnutls_sign_algorithm_t sig)
+{
+  unsigned i;
+  gnutls_protocol_t ver = gnutls_protocol_get_version (session);
+
+  if (!_gnutls_version_has_selectable_sighash (ver)
+      || session->security_parameters.extensions.sign_algorithms_size == 0)
+    /* none set, allow all */
+    {
+      return 0;
+    }
+
+  for (i = 0;
+       i < session->security_parameters.extensions.sign_algorithms_size; i++)
+    {
+      if (session->security_parameters.extensions.sign_algorithms[i] == sig)
+	{
+	  return 0;		/* ok */
+	}
+    }
+
+  return GNUTLS_E_UNSUPPORTED_SIGNATURE_ALGORITHM;
+}
+
+/* Check if the given signature algorithm is supported.
+ * This means that it is enabled by the priority functions,
+ * and in case of a server a matching certificate exists.
+ */
+int
+_gnutls_session_sign_algo_enabled (gnutls_session_t session,
+				   gnutls_sign_algorithm_t sig)
+{
+  unsigned i;
+  gnutls_protocol_t ver = gnutls_protocol_get_version (session);
+
+  if (!_gnutls_version_has_selectable_sighash (ver)
+      || session->security_parameters.extensions.sign_algorithms_size == 0)
+    /* none set, allow all */
+    {
+      return 0;
+    }
+
+  for (i = 0; i < session->internals.priorities.sign_algo.algorithms; i++)
+    {
+      if (session->internals.priorities.sign_algo.priority[i] == sig)
+	{
+	  return 0;		/* ok */
+	}
+    }
+
+  return GNUTLS_E_UNSUPPORTED_SIGNATURE_ALGORITHM;
+}
+
+/**
+ * gnutls_sign_algorithm_get_requested:
+ * @session: is a #gnutls_session_t structure.
+ * @indx: is an index of the signature algorithm to return
+ * @algo: the returned certificate type will be stored there
+ *
+ * Returns the signature algorithm specified by index that was
+ * requested by the peer. If the specified index has no data available
+ * this function returns %GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE.  If
+ * the negotiated TLS version does not support signature algorithms
+ * then %GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE will be returned even
+ * for the first index.  The first index is 0.
+ *
+ * This function is useful in the certificate callback functions
+ * to assist in selecting the correct certificate.
+ *
+ * Returns: On success, %GNUTLS_E_SUCCESS (0) is returned, otherwise
+ *   an error code is returned.
+ *
+ * Since: 2.10.0
+ **/
+int
+gnutls_sign_algorithm_get_requested (gnutls_session_t session,
+				     size_t indx,
+				     gnutls_sign_algorithm_t * algo)
+{
+  gnutls_protocol_t ver = gnutls_protocol_get_version (session);
+
+  if (!_gnutls_version_has_selectable_sighash (ver)
+      || session->security_parameters.extensions.sign_algorithms_size == 0)
+    {
+      return GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE;
+    }
+
+  if (indx < session->security_parameters.extensions.sign_algorithms_size)
+    {
+      *algo = session->security_parameters.extensions.sign_algorithms[indx];
+      return 0;
+    }
+  else
+    return GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE;
+}
diff -up gnutls-2.8.5/lib/ext_signature.h.tls12 gnutls-2.8.5/lib/ext_signature.h
--- gnutls-2.8.5/lib/ext_signature.h.tls12	2012-04-30 15:36:14.872288498 +0200
+++ gnutls-2.8.5/lib/ext_signature.h	2012-04-30 16:48:28.659134121 +0200
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2002, 2003, 2004, 2005 Free Software Foundation
+ *
+ * Author: Nikos Mavrogiannopoulos
+ *
+ * This file is part of GNUTLS.
+ *
+ * The GNUTLS library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public License
+ * as published by the Free Software Foundation; either version 2.1 of
+ * the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
+ * USA
+ *
+ */
+
+/* signature algorithms extension
+ */
+int _gnutls_signature_algorithm_recv_params (gnutls_session_t session,
+				   const opaque * data, size_t data_size);
+int _gnutls_signature_algorithm_send_params (gnutls_session_t session, opaque * data,
+				   size_t);
+int _gnutls_session_sign_algo_requested (gnutls_session_t session,
+                                     gnutls_sign_algorithm_t sig);
+gnutls_sign_algorithm_t _gnutls_session_get_sign_algo (gnutls_session_t session, gnutls_pk_algorithm_t pk, gnutls_digest_algorithm_t *hash);
+int _gnutls_sign_algorithm_parse_data(gnutls_session_t session, const opaque* data, size_t data_size);
+int _gnutls_sign_algorithm_write_params(gnutls_session_t session, opaque *data, size_t max_data_size);
+int _gnutls_session_sign_algo_enabled (gnutls_session_t session,
+                                     gnutls_sign_algorithm_t sig);
diff -up gnutls-2.8.5/lib/gnutls_alert.c.tls12 gnutls-2.8.5/lib/gnutls_alert.c
--- gnutls-2.8.5/lib/gnutls_alert.c.tls12	2012-04-27 17:16:04.000000000 +0200
+++ gnutls-2.8.5/lib/gnutls_alert.c	2012-04-30 16:08:58.551267635 +0200
@@ -203,6 +203,7 @@ gnutls_error_to_alert (int err, int *lev
     case GNUTLS_E_INSUFFICIENT_CREDENTIALS:
     case GNUTLS_E_NO_CIPHER_SUITES:
     case GNUTLS_E_NO_COMPRESSION_ALGORITHMS:
+    case GNUTLS_E_UNSUPPORTED_SIGNATURE_ALGORITHM:
     case GNUTLS_E_SAFE_RENEGOTIATION_FAILED:
       ret = GNUTLS_A_HANDSHAKE_FAILURE;
       _level = GNUTLS_AL_FATAL;
diff -up gnutls-2.8.5/lib/gnutls_algorithms.c.tls12 gnutls-2.8.5/lib/gnutls_algorithms.c
--- gnutls-2.8.5/lib/gnutls_algorithms.c.tls12	2012-04-27 17:16:04.302094378 +0200
+++ gnutls-2.8.5/lib/gnutls_algorithms.c	2012-05-03 15:18:26.238443926 +0200
@@ -234,7 +234,7 @@ static const gnutls_hash_entry hash_algo
   {"SHA512", HASH_OID_SHA512, GNUTLS_MAC_SHA512, 64},
   {"MD2", HASH_OID_MD2, GNUTLS_MAC_MD2, 0},	/* not used as MAC */
   {"RIPEMD160", HASH_OID_RMD160, GNUTLS_MAC_RMD160, 20},
-  {"NULL", NULL, GNUTLS_MAC_NULL, 0},
+  {"MAC-NULL", NULL, GNUTLS_MAC_NULL, 0},
   {0, 0, 0, 0}
 };
 
@@ -373,6 +373,9 @@ typedef struct
 #define GNUTLS_ANON_DH_CAMELLIA_256_CBC_SHA1 { 0x00,0x89 }
 #endif
 
+#define GNUTLS_ANON_DH_AES_128_CBC_SHA256 { 0x00, 0x6C }
+#define GNUTLS_ANON_DH_AES_256_CBC_SHA256 { 0x00, 0x6D }
+
 /* PSK (not in TLS 1.0)
  * draft-ietf-tls-psk:
  */
@@ -420,6 +423,9 @@ typedef struct
 #define GNUTLS_RSA_CAMELLIA_256_CBC_SHA1 { 0x00,0x84 }
 #endif
 
+#define GNUTLS_RSA_AES_128_CBC_SHA256 { 0x00, 0x3C }
+#define GNUTLS_RSA_AES_256_CBC_SHA256 { 0x00, 0x3D }
+
 /* DHE DSS
  */
 
@@ -442,6 +448,9 @@ typedef struct
 #define GNUTLS_DHE_DSS_CAMELLIA_256_CBC_SHA1 { 0x00,0x87 }
 #endif
 
+#define GNUTLS_DHE_DSS_AES_128_CBC_SHA256 { 0x00, 0x40 }
+#define GNUTLS_DHE_DSS_AES_256_CBC_SHA256 { 0x00, 0x6A }
+
 /* DHE RSA
  */
 #define GNUTLS_DHE_RSA_3DES_EDE_CBC_SHA1 { 0x00, 0x16 }
@@ -461,6 +470,9 @@ typedef struct
 
 #define GNUTLS_RENEGO_PROTECTION_REQUEST { GNUTLS_RENEGO_PROTECTION_REQUEST_MAJOR, GNUTLS_RENEGO_PROTECTION_REQUEST_MINOR }
 
+#define GNUTLS_DHE_RSA_AES_128_CBC_SHA256 { 0x00, 0x67 }
+#define GNUTLS_DHE_RSA_AES_256_CBC_SHA256 { 0x00, 0x6B }
+
 #define CIPHER_SUITES_COUNT sizeof(cs_algorithms)/sizeof(gnutls_cipher_suite_entry)-1
 
 static const gnutls_cipher_suite_entry cs_algorithms[] = {
@@ -488,6 +500,12 @@ static const gnutls_cipher_suite_entry c
 			     GNUTLS_KX_ANON_DH,
 			     GNUTLS_MAC_SHA1, GNUTLS_TLS1),
 #endif
+  GNUTLS_CIPHER_SUITE_ENTRY (GNUTLS_ANON_DH_AES_128_CBC_SHA256,
+			     GNUTLS_CIPHER_AES_128_CBC, GNUTLS_KX_ANON_DH,
+			     GNUTLS_MAC_SHA256, GNUTLS_TLS1_2),
+  GNUTLS_CIPHER_SUITE_ENTRY (GNUTLS_ANON_DH_AES_256_CBC_SHA256,
+			     GNUTLS_CIPHER_AES_256_CBC, GNUTLS_KX_ANON_DH,
+			     GNUTLS_MAC_SHA256, GNUTLS_TLS1_2),
 
   /* PSK */
   GNUTLS_CIPHER_SUITE_ENTRY (GNUTLS_PSK_SHA_ARCFOUR_SHA1,
@@ -575,6 +593,12 @@ static const gnutls_cipher_suite_entry c
 			     GNUTLS_KX_DHE_DSS,
 			     GNUTLS_MAC_SHA1, GNUTLS_TLS1),
 #endif
+  GNUTLS_CIPHER_SUITE_ENTRY (GNUTLS_DHE_DSS_AES_128_CBC_SHA256,
+			     GNUTLS_CIPHER_AES_128_CBC, GNUTLS_KX_DHE_DSS,
+			     GNUTLS_MAC_SHA256, GNUTLS_TLS1_2),
+  GNUTLS_CIPHER_SUITE_ENTRY (GNUTLS_DHE_DSS_AES_256_CBC_SHA256,
+			     GNUTLS_CIPHER_AES_256_CBC, GNUTLS_KX_DHE_DSS,
+			     GNUTLS_MAC_SHA256, GNUTLS_TLS1_2),
   /* DHE_RSA */
   GNUTLS_CIPHER_SUITE_ENTRY (GNUTLS_DHE_RSA_3DES_EDE_CBC_SHA1,
 			     GNUTLS_CIPHER_3DES_CBC, GNUTLS_KX_DHE_RSA,
@@ -595,6 +619,12 @@ static const gnutls_cipher_suite_entry c
 			     GNUTLS_KX_DHE_RSA,
 			     GNUTLS_MAC_SHA1, GNUTLS_TLS1),
 #endif
+  GNUTLS_CIPHER_SUITE_ENTRY (GNUTLS_DHE_RSA_AES_128_CBC_SHA256,
+			     GNUTLS_CIPHER_AES_128_CBC, GNUTLS_KX_DHE_RSA,
+			     GNUTLS_MAC_SHA256, GNUTLS_TLS1_2),
+  GNUTLS_CIPHER_SUITE_ENTRY (GNUTLS_DHE_RSA_AES_256_CBC_SHA256,
+			     GNUTLS_CIPHER_AES_256_CBC, GNUTLS_KX_DHE_RSA,
+			     GNUTLS_MAC_SHA256, GNUTLS_TLS1_2),
   /* RSA */
   GNUTLS_CIPHER_SUITE_ENTRY (GNUTLS_RSA_NULL_MD5,
 			     GNUTLS_CIPHER_NULL,
@@ -628,6 +658,12 @@ static const gnutls_cipher_suite_entry c
 			     GNUTLS_CIPHER_CAMELLIA_256_CBC, GNUTLS_KX_RSA,
 			     GNUTLS_MAC_SHA1, GNUTLS_TLS1),
 #endif
+  GNUTLS_CIPHER_SUITE_ENTRY (GNUTLS_RSA_AES_128_CBC_SHA256,
+                             GNUTLS_CIPHER_AES_128_CBC, GNUTLS_KX_RSA,
+                             GNUTLS_MAC_SHA256, GNUTLS_TLS1_2),
+  GNUTLS_CIPHER_SUITE_ENTRY (GNUTLS_RSA_AES_256_CBC_SHA256,
+                             GNUTLS_CIPHER_AES_256_CBC, GNUTLS_KX_RSA,
+                             GNUTLS_MAC_SHA256, GNUTLS_TLS1_2),
   GNUTLS_CIPHER_SUITE_ENTRY (GNUTLS_RENEGO_PROTECTION_REQUEST,
 			     GNUTLS_CIPHER_UNKNOWN, GNUTLS_KX_UNKNOWN,
 			     GNUTLS_MAC_UNKNOWN, GNUTLS_SSL3),
@@ -1185,6 +1221,67 @@ _gnutls_version_is_supported (gnutls_ses
     return 1;
 }
 
+
+/* This function determines if the version specified has a
+   cipher-suite selected PRF hash function instead of the old
+   hardcoded MD5+SHA1. */
+int
+_gnutls_version_has_selectable_prf (gnutls_protocol_t version)
+{
+  return version == GNUTLS_TLS1_2;
+}
+
+/* This function determines if the version specified has selectable
+   signature/hash functions for certificate authentification. */
+int
+_gnutls_version_has_selectable_sighash (gnutls_protocol_t version)
+{
+  return version == GNUTLS_TLS1_2;
+}
+
+/* This function determines if the version specified has support for
+   TLS extensions. */
+int
+_gnutls_version_has_extensions (gnutls_protocol_t version)
+{
+  switch(version) {
+  case GNUTLS_TLS1_0:
+  case GNUTLS_TLS1_1:
+  case GNUTLS_TLS1_2:
+    return 1;
+  default:
+    return 0;
+  }
+}
+
+/* This function determines if the version specified has explicit IVs
+   (for CBC attack prevention). */
+int
+_gnutls_version_has_explicit_iv (gnutls_protocol_t version)
+{
+  switch(version) {
+  case GNUTLS_TLS1_1:
+  case GNUTLS_TLS1_2:
+    return 1;
+  default:
+    return 0;
+  }
+}
+
+/* This function determines if the version specified can have
+   non-minimal padding. */
+int _gnutls_version_has_variable_padding (gnutls_protocol_t version)
+{
+  switch(version) {
+  case GNUTLS_TLS1_0:
+  case GNUTLS_TLS1_1:
+  case GNUTLS_TLS1_2:
+    return 1;
+  default:
+    return 0;
+  }
+}
+
 /* Type to KX mappings */
 gnutls_kx_algorithm_t
 _gnutls_map_kx_get_kx (gnutls_credentials_type_t type, int server)
@@ -1733,29 +1830,34 @@ struct gnutls_sign_entry
   gnutls_sign_algorithm_t id;
   gnutls_pk_algorithm_t pk;
   gnutls_mac_algorithm_t mac;
+  /* See RFC 5246 HashAlgorithm and SignatureAlgorithm
+     for values to use in aid struct. */
+  sign_algorithm_st aid;
 };
 typedef struct gnutls_sign_entry gnutls_sign_entry;
 
+#define TLS_SIGN_AID_UNKNOWN {255, 255}
+
 static const gnutls_sign_entry sign_algorithms[] = {
   {"RSA-SHA", SIG_RSA_SHA1_OID, GNUTLS_SIGN_RSA_SHA1, GNUTLS_PK_RSA,
-   GNUTLS_MAC_SHA1},
+   GNUTLS_MAC_SHA1, {2, 1}},
   {"RSA-SHA256", SIG_RSA_SHA256_OID, GNUTLS_SIGN_RSA_SHA256, GNUTLS_PK_RSA,
-   GNUTLS_MAC_SHA256},
+   GNUTLS_MAC_SHA256, {4, 1}},
   {"RSA-SHA384", SIG_RSA_SHA384_OID, GNUTLS_SIGN_RSA_SHA384, GNUTLS_PK_RSA,
-   GNUTLS_MAC_SHA384},
+   GNUTLS_MAC_SHA384, {5, 1}},
   {"RSA-SHA512", SIG_RSA_SHA512_OID, GNUTLS_SIGN_RSA_SHA512, GNUTLS_PK_RSA,
-   GNUTLS_MAC_SHA512},
+   GNUTLS_MAC_SHA512, {6, 1}},
   {"RSA-RMD160", SIG_RSA_RMD160_OID, GNUTLS_SIGN_RSA_RMD160, GNUTLS_PK_RSA,
-   GNUTLS_MAC_RMD160},
+   GNUTLS_MAC_RMD160, TLS_SIGN_AID_UNKNOWN},
   {"DSA-SHA", SIG_DSA_SHA1_OID, GNUTLS_SIGN_DSA_SHA1, GNUTLS_PK_DSA,
-   GNUTLS_MAC_SHA1},
+   GNUTLS_MAC_SHA1, {2, 2}},
   {"RSA-MD5", SIG_RSA_MD5_OID, GNUTLS_SIGN_RSA_MD5, GNUTLS_PK_RSA,
-   GNUTLS_MAC_MD5},
+   GNUTLS_MAC_MD5, {1, 1}},
   {"RSA-MD2", SIG_RSA_MD2_OID, GNUTLS_SIGN_RSA_MD2, GNUTLS_PK_RSA,
-   GNUTLS_MAC_MD2},
-  {"GOST R 34.10-2001", SIG_GOST_R3410_2001_OID, 0, 0, 0},
-  {"GOST R 34.10-94", SIG_GOST_R3410_94_OID, 0, 0, 0},
-  {0, 0, 0, 0, 0}
+   GNUTLS_MAC_MD2, TLS_SIGN_AID_UNKNOWN},
+  {"GOST R 34.10-2001", SIG_GOST_R3410_2001_OID, 0, 0, 0, TLS_SIGN_AID_UNKNOWN},
+  {"GOST R 34.10-94", SIG_GOST_R3410_94_OID, 0, 0, 0, TLS_SIGN_AID_UNKNOWN},
+  {0, 0, 0, 0, 0, TLS_SIGN_AID_UNKNOWN}
 };
 
 /* Keep the contents of this struct the same as the previous one. */
@@ -1861,7 +1963,7 @@ _gnutls_x509_oid2sign_algorithm (const c
 {
   gnutls_sign_algorithm_t ret = 0;
 
-  GNUTLS_SIGN_LOOP (if (strcmp (oid, p->oid) == 0)
+  GNUTLS_SIGN_LOOP (if (p->oid && strcmp (oid, p->oid) == 0)
 		    {
 		    ret = p->id; break;}
   );
@@ -1904,6 +2006,52 @@ _gnutls_x509_sign_to_oid (gnutls_pk_algo
   return ret;
 }
 
+gnutls_mac_algorithm_t
+_gnutls_sign_get_hash_algorithm (gnutls_sign_algorithm_t sign)
+{
+  gnutls_mac_algorithm_t ret = GNUTLS_DIG_UNKNOWN;
+
+  GNUTLS_SIGN_ALG_LOOP (ret = p->mac);
+
+  return ret;
+}
+
+gnutls_pk_algorithm_t
+_gnutls_sign_get_pk_algorithm (gnutls_sign_algorithm_t sign)
+{
+  gnutls_pk_algorithm_t ret = GNUTLS_PK_UNKNOWN;
+
+  GNUTLS_SIGN_ALG_LOOP (ret = p->pk);
+
+  return ret;
+}
+
+gnutls_sign_algorithm_t
+_gnutls_tls_aid_to_sign (const sign_algorithm_st *aid)
+{
+  gnutls_sign_algorithm_t ret = GNUTLS_SIGN_UNKNOWN;
+
+  GNUTLS_SIGN_LOOP ( if (p->aid.hash_algorithm == aid->hash_algorithm
+			 && p->aid.sign_algorithm == aid->sign_algorithm)
+		       {
+			 ret = p->id;
+			 break;
+		       } );
+
+  return ret;
+}
+
+sign_algorithm_st
+_gnutls_sign_to_tls_aid (gnutls_sign_algorithm_t sign)
+{
+  sign_algorithm_st ret = TLS_SIGN_AID_UNKNOWN;
+
+  GNUTLS_SIGN_ALG_LOOP (ret = p->aid);
+
+  return ret;
+}
+
+
 
 /* pk algorithms;
  */
@@ -2036,7 +2184,7 @@ _gnutls_x509_oid2pk_algorithm (const cha
   const gnutls_pk_entry *p;
 
   for (p = pk_algorithms; p->name != NULL; p++)
-    if (strcmp (p->oid, oid) == 0)
+    if (p->oid && strcmp (p->oid, oid) == 0)
       {
 	ret = p->id;
 	break;
diff -up gnutls-2.8.5/lib/gnutls_algorithms.h.tls12 gnutls-2.8.5/lib/gnutls_algorithms.h
--- gnutls-2.8.5/lib/gnutls_algorithms.h.tls12	2012-04-27 17:16:04.302094378 +0200
+++ gnutls-2.8.5/lib/gnutls_algorithms.h	2012-04-30 16:48:28.661134165 +0200
@@ -41,6 +41,13 @@ int _gnutls_version_get_major (gnutls_pr
 int _gnutls_version_get_minor (gnutls_protocol_t ver);
 gnutls_protocol_t _gnutls_version_get (int major, int minor);
 
+/* Functions for feature checks */
+int _gnutls_version_has_selectable_prf (gnutls_protocol_t version);
+int _gnutls_version_has_selectable_sighash (gnutls_protocol_t version);
+int _gnutls_version_has_extensions (gnutls_protocol_t version);
+int _gnutls_version_has_explicit_iv (gnutls_protocol_t version);
+int _gnutls_version_has_variable_padding (gnutls_protocol_t version);
+
 /* Functions for MACs. */
 int _gnutls_mac_is_ok (gnutls_mac_algorithm_t algorithm);
 gnutls_mac_algorithm_t _gnutls_x509_oid2mac_algorithm (const char *oid);
@@ -99,8 +106,13 @@ enum encipher_type _gnutls_kx_encipher_t
 gnutls_sign_algorithm_t _gnutls_x509_oid2sign_algorithm (const char *oid);
 gnutls_sign_algorithm_t _gnutls_x509_pk_to_sign (gnutls_pk_algorithm_t pk,
 						 gnutls_mac_algorithm_t mac);
+gnutls_pk_algorithm_t _gnutls_x509_sign_to_pk (gnutls_sign_algorithm_t sign);
 const char *_gnutls_x509_sign_to_oid (gnutls_pk_algorithm_t,
 				      gnutls_mac_algorithm_t mac);
+gnutls_sign_algorithm_t _gnutls_tls_aid_to_sign (const sign_algorithm_st* aid);
+sign_algorithm_st _gnutls_sign_to_tls_aid (gnutls_sign_algorithm_t sign);
+gnutls_mac_algorithm_t _gnutls_sign_get_hash_algorithm (gnutls_sign_algorithm_t);
+gnutls_pk_algorithm_t _gnutls_sign_get_pk_algorithm (gnutls_sign_algorithm_t);
 
 int _gnutls_mac_priority (gnutls_session_t session,
 			  gnutls_mac_algorithm_t algorithm);
diff -up gnutls-2.8.5/lib/gnutls_buffers.c.tls12 gnutls-2.8.5/lib/gnutls_buffers.c
--- gnutls-2.8.5/lib/gnutls_buffers.c.tls12	2009-11-02 11:30:39.000000000 +0100
+++ gnutls-2.8.5/lib/gnutls_buffers.c	2012-04-27 17:16:04.328094956 +0200
@@ -1091,24 +1091,6 @@ _gnutls_handshake_buffer_get_size (gnutl
  * and returns data from it (peek mode!)
  */
 int
-_gnutls_handshake_buffer_peek (gnutls_session_t session, opaque * data,
-			       size_t length)
-{
-  if (length > session->internals.handshake_hash_buffer.length)
-    {
-      length = session->internals.handshake_hash_buffer.length;
-    }
-
-  _gnutls_buffers_log ("BUF[HSK]: Peeked %d bytes of Data\n", length);
-
-  memcpy (data, session->internals.handshake_hash_buffer.data, length);
-  return length;
-}
-
-/* this function does not touch the buffer
- * and returns data from it (peek mode!)
- */
-int
 _gnutls_handshake_buffer_get_ptr (gnutls_session_t session,
 				  opaque ** data_ptr, size_t * length)
 {
@@ -1142,7 +1124,6 @@ _gnutls_handshake_buffer_clear (gnutls_s
 {
 
   _gnutls_buffers_log ("BUF[HSK]: Cleared Data from buffer\n");
-
   _gnutls_buffer_clear (&session->internals.handshake_hash_buffer);
 
   return 0;
diff -up gnutls-2.8.5/lib/gnutls_buffers.h.tls12 gnutls-2.8.5/lib/gnutls_buffers.h
--- gnutls-2.8.5/lib/gnutls_buffers.h.tls12	2009-11-02 11:30:39.000000000 +0100
+++ gnutls-2.8.5/lib/gnutls_buffers.h	2012-04-27 17:16:04.328094956 +0200
@@ -41,8 +41,6 @@ ssize_t _gnutls_io_write_buffered2 (gnut
 				    size_t n, const void *iptr2, size_t n2);
 
 int _gnutls_handshake_buffer_get_size (gnutls_session_t session);
-int _gnutls_handshake_buffer_peek (gnutls_session_t session, opaque * data,
-				   size_t length);
 int _gnutls_handshake_buffer_put (gnutls_session_t session, opaque * data,
 				  size_t length);
 int _gnutls_handshake_buffer_clear (gnutls_session_t session);
diff -up gnutls-2.8.5/lib/gnutls_cert.c.tls12 gnutls-2.8.5/lib/gnutls_cert.c
--- gnutls-2.8.5/lib/gnutls_cert.c.tls12	2009-08-12 08:58:13.000000000 +0200
+++ gnutls-2.8.5/lib/gnutls_cert.c	2012-04-30 15:36:14.875288564 +0200
@@ -817,6 +817,7 @@ _gnutls_x509_crt_to_gcert (gnutls_cert *
 
   memset (gcert, 0, sizeof (gnutls_cert));
   gcert->cert_type = GNUTLS_CRT_X509;
+  gcert->sign_algo = gnutls_x509_crt_get_signature_algorithm(cert);
 
   if (!(flags & CERT_NO_COPY))
     {
diff -up gnutls-2.8.5/lib/gnutls_cert.h.tls12 gnutls-2.8.5/lib/gnutls_cert.h
--- gnutls-2.8.5/lib/gnutls_cert.h.tls12	2009-06-02 20:59:32.000000000 +0200
+++ gnutls-2.8.5/lib/gnutls_cert.h	2012-04-30 15:36:14.876288586 +0200
@@ -71,6 +71,7 @@ typedef struct gnutls_cert
   /* holds the type (PGP, X509)
    */
   gnutls_certificate_type_t cert_type;
+  gnutls_sign_algorithm_t sign_algo;
 
   gnutls_datum_t raw;
 
diff -up gnutls-2.8.5/lib/gnutls_cipher.c.tls12 gnutls-2.8.5/lib/gnutls_cipher.c
--- gnutls-2.8.5/lib/gnutls_cipher.c.tls12	2012-04-27 17:16:04.324094866 +0200
+++ gnutls-2.8.5/lib/gnutls_cipher.c	2012-04-27 17:16:04.329094978 +0200
@@ -201,7 +201,6 @@ mac_init (digest_hd_st * td, gnutls_mac_
 
   if (mac == GNUTLS_MAC_NULL)
     {
-      gnutls_assert ();
       return GNUTLS_E_HASH_FAILED;
     }
 
@@ -275,7 +274,7 @@ calc_enc_length (gnutls_session_t sessio
       *pad = (uint8_t) (blocksize - (length % blocksize)) + rnd;
 
       length += *pad;
-      if (session->security_parameters.version >= GNUTLS_TLS1_1)
+      if (_gnutls_version_has_explicit_iv(session->security_parameters.version))
 	length += blocksize;	/* for the IV */
 
       break;
@@ -344,7 +343,7 @@ _gnutls_compressed2ciphertext (gnutls_se
 				write_sequence_number), 8);
 
       _gnutls_hmac (&td, &type, 1);
-      if (ver >= GNUTLS_TLS1)
+      if (_gnutls_version_has_variable_padding(ver))
 	{			/* TLS 1.0 or higher */
 	  _gnutls_hmac (&td, &major, 1);
 	  _gnutls_hmac (&td, &minor, 1);
@@ -376,7 +375,7 @@ _gnutls_compressed2ciphertext (gnutls_se
 
   data_ptr = cipher_data;
   if (block_algo == CIPHER_BLOCK &&
-      session->security_parameters.version >= GNUTLS_TLS1_1)
+      _gnutls_version_has_explicit_iv(session->security_parameters.version))
     {
       /* copy the random IV.
        */
@@ -418,6 +417,10 @@ _gnutls_compressed2ciphertext (gnutls_se
   return length;
 }
 
+#define DEINIT_MAC(td, ver, algo) \
+          if (algo != GNUTLS_MAC_NULL) \
+            mac_deinit (&td, NULL, ver);
+
 /* Deciphers the ciphertext packet, and puts the result to compress_data, of compress_size.
  * Returns the actual compressed packet size.
  */
@@ -473,6 +476,9 @@ _gnutls_ciphertext2compressed (gnutls_se
 				   ciphertext.size)) < 0)
 	{
 	  gnutls_assert ();
+	  DEINIT_MAC(td, ver, session->security_parameters.write_mac_algorithm);
+
+
 	  return ret;
 	}
 
@@ -483,6 +489,7 @@ _gnutls_ciphertext2compressed (gnutls_se
       if ((ciphertext.size < blocksize) || (ciphertext.size % blocksize != 0))
 	{
 	  gnutls_assert ();
+	  DEINIT_MAC(td, ver, session->security_parameters.write_mac_algorithm);
 	  return GNUTLS_E_DECRYPTION_FAILED;
 	}
 
@@ -492,12 +499,13 @@ _gnutls_ciphertext2compressed (gnutls_se
 				   ciphertext.size)) < 0)
 	{
 	  gnutls_assert ();
+	  DEINIT_MAC(td, ver, session->security_parameters.write_mac_algorithm);
 	  return ret;
 	}
 
       /* ignore the IV in TLS 1.1.
        */
-      if (session->security_parameters.version >= GNUTLS_TLS1_1)
+      if (_gnutls_version_has_explicit_iv(session->security_parameters.version))
 	{
 	  ciphertext.size -= blocksize;
 	  ciphertext.data += blocksize;
@@ -506,6 +514,7 @@ _gnutls_ciphertext2compressed (gnutls_se
       if (ciphertext.size < hash_size)
 	{
 	  gnutls_assert ();
+	  DEINIT_MAC(td, ver, session->security_parameters.write_mac_algorithm);
 	  return GNUTLS_E_DECRYPTION_FAILED;
 	}
       pad = ciphertext.data[ciphertext.size - 1] + 1;	/* pad */
@@ -526,7 +535,7 @@ _gnutls_ciphertext2compressed (gnutls_se
 
       /* Check the pading bytes (TLS 1.x)
        */
-      if (ver >= GNUTLS_TLS1 && pad_failed == 0)
+      if (_gnutls_version_has_variable_padding(ver) && pad_failed == 0)
 	for (i = 2; i < pad; i++)
 	  {
 	    if (ciphertext.data[ciphertext.size - i] !=
@@ -536,6 +545,7 @@ _gnutls_ciphertext2compressed (gnutls_se
       break;
     default:
       gnutls_assert ();
+      DEINIT_MAC(td, ver, session->security_parameters.write_mac_algorithm);
       return GNUTLS_E_INTERNAL_ERROR;
     }
 
@@ -553,7 +563,7 @@ _gnutls_ciphertext2compressed (gnutls_se
 				read_sequence_number), 8);
 
       _gnutls_hmac (&td, &type, 1);
-      if (ver >= GNUTLS_TLS1)
+      if (_gnutls_version_has_variable_padding(ver))
 	{			/* TLS 1.x */
 	  _gnutls_hmac (&td, &major, 1);
 	  _gnutls_hmac (&td, &minor, 1);
diff -up gnutls-2.8.5/lib/gnutls_errors.c.tls12 gnutls-2.8.5/lib/gnutls_errors.c
--- gnutls-2.8.5/lib/gnutls_errors.c.tls12	2012-04-27 17:16:04.303094400 +0200
+++ gnutls-2.8.5/lib/gnutls_errors.c	2012-04-30 15:36:14.876288586 +0200
@@ -232,6 +232,8 @@ static const gnutls_error_entry error_al
 
   ERROR_ENTRY (N_("The OpenPGP fingerprint is not supported."),
 	       GNUTLS_E_OPENPGP_FINGERPRINT_UNSUPPORTED, 1),
+  ERROR_ENTRY (N_("The signature algorithm is not supported."),
+	       GNUTLS_E_UNSUPPORTED_SIGNATURE_ALGORITHM, 1),
   ERROR_ENTRY (N_("The certificate has unsupported attributes."),
 	       GNUTLS_E_X509_UNSUPPORTED_ATTRIBUTE, 1),
   ERROR_ENTRY (N_("The OID is not supported."), GNUTLS_E_X509_UNSUPPORTED_OID,
diff -up gnutls-2.8.5/lib/gnutls_extensions.c.tls12 gnutls-2.8.5/lib/gnutls_extensions.c
--- gnutls-2.8.5/lib/gnutls_extensions.c.tls12	2012-04-27 17:16:04.304094422 +0200
+++ gnutls-2.8.5/lib/gnutls_extensions.c	2012-04-30 15:46:34.068340023 +0200
@@ -35,6 +35,7 @@
 #include <ext_server_name.h>
 #include <ext_oprfi.h>
 #include <ext_srp.h>
+#include <ext_signature.h>
 #include <ext_safe_renegotiation.h>
 #include <gnutls_num.h>
 
@@ -338,6 +339,14 @@ _gnutls_ext_init (void)
     return ret;
 #endif
 
+  ret = gnutls_ext_register (GNUTLS_EXTENSION_SIGNATURE_ALGORITHMS,
+			      "SIGNATURE_ALGORITHMS",
+			      GNUTLS_EXT_TLS,
+			      _gnutls_signature_algorithm_recv_params,
+			      _gnutls_signature_algorithm_send_params);
+  if (ret != GNUTLS_E_SUCCESS)
+    return ret;
+
   return GNUTLS_E_SUCCESS;
 }
 
diff -up gnutls-2.8.5/lib/gnutls_handshake.c.tls12 gnutls-2.8.5/lib/gnutls_handshake.c
--- gnutls-2.8.5/lib/gnutls_handshake.c.tls12	2012-04-27 17:16:04.306094466 +0200
+++ gnutls-2.8.5/lib/gnutls_handshake.c	2012-05-03 15:04:03.700345742 +0200
@@ -63,17 +63,32 @@
 #define TRUE 1
 #define FALSE 0
 
-int _gnutls_server_select_comp_method (gnutls_session_t session,
+static int _gnutls_handshake_hash_init (gnutls_session_t session);
+static int _gnutls_server_select_comp_method (gnutls_session_t session,
 				       opaque * data, int datalen);
+static int
+_gnutls_handshake_hash_add_recvd (gnutls_session_t session,
+				  gnutls_handshake_description_t recv_type,
+				  opaque * header, uint16_t header_size,
+				  opaque * dataptr, uint32_t datalen);
 
 
 /* Clears the handshake hash buffers and handles.
  */
-static void
+void
 _gnutls_handshake_hash_buffers_clear (gnutls_session_t session)
 {
-  _gnutls_hash_deinit (&session->internals.handshake_mac_handle_md5, NULL);
-  _gnutls_hash_deinit (&session->internals.handshake_mac_handle_sha, NULL);
+  if (session->security_parameters.handshake_mac_handle_type == HANDSHAKE_MAC_TYPE_10) 
+    {
+      _gnutls_hash_deinit (&session->internals.handshake_mac_handle.tls10.md5, NULL);
+      _gnutls_hash_deinit (&session->internals.handshake_mac_handle.tls10.sha, NULL);
+    }
+  else if (session->security_parameters.handshake_mac_handle_type == HANDSHAKE_MAC_TYPE_12)
+    {
+      _gnutls_hash_deinit (&session->internals.handshake_mac_handle.tls12.sha256, NULL);
+      _gnutls_hash_deinit (&session->internals.handshake_mac_handle.tls12.sha1, NULL);
+    }
+  session->security_parameters.handshake_mac_handle_type = 0;
   session->internals.handshake_mac_handle_init = 0;
   _gnutls_handshake_buffer_clear (session);
 }
@@ -151,23 +166,33 @@ _gnutls_ssl3_finished (gnutls_session_t
   const char *mesg;
   int rc;
 
-  rc =
-    _gnutls_hash_copy (&td_md5, &session->internals.handshake_mac_handle_md5);
-  if (rc < 0)
+  if (session->security_parameters.handshake_mac_handle_type == HANDSHAKE_MAC_TYPE_10) 
     {
-      gnutls_assert ();
-      return rc;
-    }
+      rc =
+        _gnutls_hash_copy (&td_md5, &session->internals.handshake_mac_handle.tls10.md5);
+      if (rc < 0)
+        {
+          gnutls_assert ();
+          return rc;
+        }
+
+      rc =
+        _gnutls_hash_copy (&td_sha, &session->internals.handshake_mac_handle.tls10.sha);
+      if (rc < 0)
+        {
+          gnutls_assert ();
+          _gnutls_hash_deinit (&td_md5, NULL);
+          return rc;
+        }
 
-  rc =
-    _gnutls_hash_copy (&td_sha, &session->internals.handshake_mac_handle_sha);
-  if (rc < 0)
+    }
+  else
     {
-      gnutls_assert ();
-      _gnutls_hash_deinit (&td_md5, NULL);
-      return rc;
+      gnutls_assert();
+      return GNUTLS_E_INTERNAL_ERROR;
     }
 
+
   if (type == GNUTLS_SERVER)
     {
       mesg = SSL3_SERVER_MSG;
@@ -199,7 +224,7 @@ static int
 _gnutls_finished (gnutls_session_t session, int type, void *ret)
 {
   const int siz = TLS_MSG_LEN;
-  opaque concat[36];
+  opaque concat[MAX_HASH_SIZE+16/*MD5*/];
   size_t len;
   const char *mesg;
   digest_hd_st td_md5;
@@ -207,39 +232,45 @@ _gnutls_finished (gnutls_session_t sessi
   gnutls_protocol_t ver = gnutls_protocol_get_version (session);
   int rc;
 
-  if (ver < GNUTLS_TLS1_2)
+  if (session->security_parameters.handshake_mac_handle_type == HANDSHAKE_MAC_TYPE_10) 
     {
       rc =
 	_gnutls_hash_copy (&td_md5,
-			   &session->internals.handshake_mac_handle_md5);
+			   &session->internals.handshake_mac_handle.tls10.md5);
       if (rc < 0)
 	{
 	  gnutls_assert ();
 	  return rc;
 	}
-    }
 
-  rc =
-    _gnutls_hash_copy (&td_sha, &session->internals.handshake_mac_handle_sha);
-  if (rc < 0)
-    {
-      gnutls_assert ();
-      _gnutls_hash_deinit (&td_md5, NULL);
-      return rc;
-    }
+      rc =
+        _gnutls_hash_copy (&td_sha, &session->internals.handshake_mac_handle.tls10.sha);
+      if (rc < 0)
+        {
+          gnutls_assert ();
+          _gnutls_hash_deinit (&td_md5, NULL);
+          return rc;
+        }
 
-  if (ver < GNUTLS_TLS1_2)
-    {
-      _gnutls_hash_deinit (&td_md5, concat);
-      _gnutls_hash_deinit (&td_sha, &concat[16]);
-      len = 20 + 16;
+        _gnutls_hash_deinit (&td_md5, concat);
+        _gnutls_hash_deinit (&td_sha, &concat[16]);
+        len = 20 + 16;
     }
-  else
+  else if (session->security_parameters.handshake_mac_handle_type == HANDSHAKE_MAC_TYPE_12) 
     {
-      _gnutls_hash_deinit (&td_sha, concat);
-      len = 20;
+      rc =
+        _gnutls_hash_copy (&td_sha, &session->internals.handshake_mac_handle.tls12.sha256);
+      if (rc < 0)
+        {
+          gnutls_assert ();
+          return rc;
+        }
+
+        _gnutls_hash_deinit (&td_sha, concat);
+        len = _gnutls_hash_get_algo_len (td_sha.algorithm);
     }
 
+
   if (type == GNUTLS_SERVER)
     {
       mesg = SERVER_MSG;
@@ -548,8 +579,16 @@ _gnutls_handshake_hash_pending (gnutls_s
 
   if (siz > 0)
     {
-      _gnutls_hash (&session->internals.handshake_mac_handle_sha, data, siz);
-      _gnutls_hash (&session->internals.handshake_mac_handle_md5, data, siz);
+      if (session->security_parameters.handshake_mac_handle_type == HANDSHAKE_MAC_TYPE_10) 
+        {
+          _gnutls_hash (&session->internals.handshake_mac_handle.tls10.sha, data, siz);
+          _gnutls_hash (&session->internals.handshake_mac_handle.tls10.md5, data, siz);
+        } 
+      else if (session->security_parameters.handshake_mac_handle_type == HANDSHAKE_MAC_TYPE_12)
+        {
+          _gnutls_hash (&session->internals.handshake_mac_handle.tls12.sha256, data, siz);
+          _gnutls_hash (&session->internals.handshake_mac_handle.tls12.sha1, data, siz);
+        }
     }
 
   _gnutls_handshake_buffer_empty (session);
@@ -699,12 +738,14 @@ _gnutls_recv_finished (gnutls_session_t
       return ret;
     }
 
-  if (memcmp (vrfy, data, data_size) != 0)
+  ret = memcmp (vrfy, data, data_size);
+  gnutls_free (vrfy);
+  
+  if (ret != 0)
     {
       gnutls_assert ();
-      ret = GNUTLS_E_ERROR_IN_FINISHED_PACKET;
+      return GNUTLS_E_ERROR_IN_FINISHED_PACKET;
     }
-  gnutls_free (vrfy);
 
   /* Save peer's verify data for safe renegotiation */
   if (data_size > MAX_VERIFY_DATA_SIZE)
@@ -728,7 +769,7 @@ _gnutls_recv_finished (gnutls_session_t
 
   session->internals.initial_negotiation_completed = 1;
 
-  return ret;
+  return 0;
 }
 
 /* returns PK_RSA if the given cipher suite list only supports,
@@ -917,7 +958,7 @@ finish:
 
 /* This selects the best supported compression method from the ones provided 
  */
-int
+static int
 _gnutls_server_select_comp_method (gnutls_session_t session,
 				   opaque * data, int datalen)
 {
@@ -996,6 +1037,18 @@ _gnutls_handshake_hash_add_sent (gnutls_
 {
   int ret;
 
+  if (session->security_parameters.entity == GNUTLS_CLIENT && type == GNUTLS_HANDSHAKE_CLIENT_HELLO)
+    {
+      /* do not hash immediatelly since the hash has not yet been initialized */
+      if ((ret =
+	   _gnutls_handshake_buffer_put (session, dataptr, datalen)) < 0)
+	{
+	  gnutls_assert ();
+	  return ret;
+	}
+      return 0;
+    }
+
   if ((ret = _gnutls_handshake_hash_pending (session)) < 0)
     {
       gnutls_assert ();
@@ -1004,10 +1057,20 @@ _gnutls_handshake_hash_add_sent (gnutls_
 
   if (type != GNUTLS_HANDSHAKE_HELLO_REQUEST)
     {
-      _gnutls_hash (&session->internals.handshake_mac_handle_sha, dataptr,
+      if (session->security_parameters.handshake_mac_handle_type == HANDSHAKE_MAC_TYPE_10) 
+        {
+          _gnutls_hash (&session->internals.handshake_mac_handle.tls10.sha, dataptr,
 		    datalen);
-      _gnutls_hash (&session->internals.handshake_mac_handle_md5, dataptr,
+          _gnutls_hash (&session->internals.handshake_mac_handle.tls10.md5, dataptr,
 		    datalen);
+        }
+      else if (session->security_parameters.handshake_mac_handle_type == HANDSHAKE_MAC_TYPE_12) 
+        { 
+          _gnutls_hash (&session->internals.handshake_mac_handle.tls12.sha256, dataptr,
+		    datalen);
+          _gnutls_hash (&session->internals.handshake_mac_handle.tls12.sha1, dataptr,
+		    datalen);
+        }
     }
 
   return 0;
@@ -1245,11 +1308,14 @@ _gnutls_handshake_hash_add_recvd (gnutls
   /* The idea here is to hash the previous message we received,
    * and add the one we just received into the handshake_hash_buffer.
    */
-
-  if ((ret = _gnutls_handshake_hash_pending (session)) < 0)
+  if ((session->security_parameters.entity == GNUTLS_SERVER || recv_type != GNUTLS_HANDSHAKE_SERVER_HELLO) && 
+      (session->security_parameters.entity == GNUTLS_CLIENT || recv_type != GNUTLS_HANDSHAKE_CLIENT_HELLO))
     {
-      gnutls_assert ();
-      return ret;
+      if ((ret = _gnutls_handshake_hash_pending (session)) < 0)
+        {
+          gnutls_assert ();
+          return ret;
+        }
     }
 
   /* here we buffer the handshake messages - needed at Finished message */
@@ -1372,11 +1438,23 @@ _gnutls_recv_handshake (gnutls_session_t
     case GNUTLS_HANDSHAKE_CLIENT_HELLO:
     case GNUTLS_HANDSHAKE_SERVER_HELLO:
       ret = _gnutls_recv_hello (session, dataptr, length32);
+      
       /* dataptr is freed because the caller does not
        * need it */
       gnutls_free (dataptr);
       if (data != NULL)
 	*data = NULL;
+      
+      if (ret < 0)
+        break;
+
+      /* initialize the hashes for both - (client will know server's version
+       * and server as well at this point) */
+      if ((ret = _gnutls_handshake_hash_init (session)) < 0) {
+        gnutls_assert();
+        return ret;
+      }
+
       break;
     case GNUTLS_HANDSHAKE_SERVER_HELLO_DONE:
       if (length32 == 0)
@@ -1997,7 +2075,7 @@ _gnutls_send_client_hello (gnutls_sessio
 
       /* Generate and copy TLS extensions.
        */
-      if (hver >= GNUTLS_TLS1)
+      if (_gnutls_version_has_extensions(hver))
 	type = GNUTLS_EXT_ANY;
       else
 	{
@@ -2372,30 +2450,68 @@ _gnutls_abort_handshake (gnutls_session_
 /* This function initialized the handshake hash session.
  * required for finished messages.
  */
-inline static int
+static int
 _gnutls_handshake_hash_init (gnutls_session_t session)
 {
+  gnutls_protocol_t ver = gnutls_protocol_get_version (session);
 
   if (session->internals.handshake_mac_handle_init == 0)
     {
-      int ret =
-	_gnutls_hash_init (&session->internals.handshake_mac_handle_md5,
+      int ret;
+
+      /* set the hash type for handshake message hashing */
+      if (_gnutls_version_has_selectable_prf (ver))
+        session->security_parameters.handshake_mac_handle_type = HANDSHAKE_MAC_TYPE_12;
+      else
+        session->security_parameters.handshake_mac_handle_type = HANDSHAKE_MAC_TYPE_10;
+
+
+      if (session->security_parameters.handshake_mac_handle_type == HANDSHAKE_MAC_TYPE_10) 
+        {
+          ret =
+  	    _gnutls_hash_init (&session->internals.handshake_mac_handle.tls10.md5,
 			   GNUTLS_MAC_MD5);
 
-      if (ret < 0)
-	{
-	  gnutls_assert ();
-	  return ret;
-	}
+          if (ret < 0)
+  	    {
+	      gnutls_assert ();
+	      return ret;
+	    }
 
-      ret =
-	_gnutls_hash_init (&session->internals.handshake_mac_handle_sha,
+          ret =
+            _gnutls_hash_init (&session->internals.handshake_mac_handle.tls10.sha,
 			   GNUTLS_MAC_SHA1);
-      if (ret < 0)
-	{
-	  gnutls_assert ();
-	  return GNUTLS_E_MEMORY_ERROR;
-	}
+          if (ret < 0)
+	    {
+	      gnutls_assert ();
+	      _gnutls_hash_deinit (&session->internals.handshake_mac_handle.tls10.md5, NULL);
+	      return GNUTLS_E_MEMORY_ERROR;
+	    }
+        }
+      else if (session->security_parameters.handshake_mac_handle_type == HANDSHAKE_MAC_TYPE_12)
+        {
+        /* The algorithm to compute hash over handshake messages must be
+  	   same as the one used as the basis for PRF.  By now we use
+	   SHA256. */
+          ret =
+           _gnutls_hash_init (&session->internals.handshake_mac_handle.tls12.sha256,
+			   GNUTLS_DIG_SHA256);
+           if (ret < 0)
+	     {
+	       gnutls_assert ();
+	       return GNUTLS_E_MEMORY_ERROR;
+  	     }
+
+          ret =
+           _gnutls_hash_init (&session->internals.handshake_mac_handle.tls12.sha1,
+			   GNUTLS_DIG_SHA1);
+           if (ret < 0)
+	     {
+	       gnutls_assert ();
+	       _gnutls_hash_deinit(&session->internals.handshake_mac_handle.tls12.sha256, NULL);
+	       return GNUTLS_E_MEMORY_ERROR;
+  	     }
+        }
 
       session->internals.handshake_mac_handle_init = 1;
     }
@@ -2495,12 +2611,6 @@ gnutls_handshake (gnutls_session_t sessi
 {
   int ret;
 
-  if ((ret = _gnutls_handshake_hash_init (session)) < 0)
-    {
-      gnutls_assert ();
-      return ret;
-    }
-
   if (session->security_parameters.entity == GNUTLS_CLIENT)
     {
       ret = _gnutls_handshake_client (session);
@@ -2538,9 +2648,9 @@ gnutls_handshake (gnutls_session_t sessi
   return 0;
 }
 
-#define IMED_RET( str, ret) do { \
+#define IMED_RET( str, ret, check_fatal) do { \
 	if (ret < 0) { \
-		if (gnutls_error_is_fatal(ret)==0) return ret; \
+		if (check_fatal != 0 && gnutls_error_is_fatal(ret)==0) return ret; \
 		gnutls_assert(); \
 		ERR( str, ret); \
 		_gnutls_handshake_hash_buffers_clear(session); \
@@ -2578,7 +2688,7 @@ _gnutls_handshake_client (gnutls_session
     case STATE1:
       ret = _gnutls_send_hello (session, AGAIN (STATE1));
       STATE = STATE1;
-      IMED_RET ("send hello", ret);
+      IMED_RET ("send hello", ret, 0);
 
     case STATE2:
       /* receive the server hello */
@@ -2587,14 +2697,14 @@ _gnutls_handshake_client (gnutls_session
 				GNUTLS_HANDSHAKE_SERVER_HELLO,
 				MANDATORY_PACKET);
       STATE = STATE2;
-      IMED_RET ("recv hello", ret);
+      IMED_RET ("recv hello", ret, 1);
 
     case STATE70:
       if (session->security_parameters.extensions.do_recv_supplemental)
 	{
 	  ret = _gnutls_recv_supplemental (session);
 	  STATE = STATE70;
-	  IMED_RET ("recv supplemental", ret);
+	  IMED_RET ("recv supplemental", ret, 1);
 	}
 
     case STATE3:
@@ -2602,14 +2712,14 @@ _gnutls_handshake_client (gnutls_session
       if (session->internals.resumed == RESUME_FALSE)	/* if we are not resuming */
 	ret = _gnutls_recv_server_certificate (session);
       STATE = STATE3;
-      IMED_RET ("recv server certificate", ret);
+      IMED_RET ("recv server certificate", ret, 1);
 
     case STATE4:
       /* receive the server key exchange */
       if (session->internals.resumed == RESUME_FALSE)	/* if we are not resuming */
 	ret = _gnutls_recv_server_kx_message (session);
       STATE = STATE4;
-      IMED_RET ("recv server kx message", ret);
+      IMED_RET ("recv server kx message", ret, 1);
 
     case STATE5:
       /* receive the server certificate request - if any 
@@ -2618,7 +2728,7 @@ _gnutls_handshake_client (gnutls_session
       if (session->internals.resumed == RESUME_FALSE)	/* if we are not resuming */
 	ret = _gnutls_recv_server_certificate_request (session);
       STATE = STATE5;
-      IMED_RET ("recv server certificate request message", ret);
+      IMED_RET ("recv server certificate request message", ret, 1);
 
     case STATE6:
       /* receive the server hello done */
@@ -2628,14 +2738,14 @@ _gnutls_handshake_client (gnutls_session
 				  GNUTLS_HANDSHAKE_SERVER_HELLO_DONE,
 				  MANDATORY_PACKET);
       STATE = STATE6;
-      IMED_RET ("recv server hello done", ret);
+      IMED_RET ("recv server hello done", ret, 1);
 
     case STATE71:
       if (session->security_parameters.extensions.do_send_supplemental)
 	{
 	  ret = _gnutls_send_supplemental (session, AGAIN (STATE71));
 	  STATE = STATE71;
-	  IMED_RET ("send supplemental", ret);
+	  IMED_RET ("send supplemental", ret, 0);
 	}
 
     case STATE7:
@@ -2644,13 +2754,13 @@ _gnutls_handshake_client (gnutls_session
       if (session->internals.resumed == RESUME_FALSE)	/* if we are not resuming */
 	ret = _gnutls_send_client_certificate (session, AGAIN (STATE7));
       STATE = STATE7;
-      IMED_RET ("send client certificate", ret);
+      IMED_RET ("send client certificate", ret, 0);
 
     case STATE8:
       if (session->internals.resumed == RESUME_FALSE)	/* if we are not resuming */
 	ret = _gnutls_send_client_kx_message (session, AGAIN (STATE8));
       STATE = STATE8;
-      IMED_RET ("send client kx", ret);
+      IMED_RET ("send client kx", ret, 0);
 
     case STATE9:
       /* send client certificate verify */
@@ -2658,7 +2768,7 @@ _gnutls_handshake_client (gnutls_session
 	ret =
 	  _gnutls_send_client_certificate_verify (session, AGAIN (STATE9));
       STATE = STATE9;
-      IMED_RET ("send client certificate verify", ret);
+      IMED_RET ("send client certificate verify", ret, 0);
 
       STATE = STATE0;
     default:
@@ -2807,19 +2917,19 @@ _gnutls_handshake_server (gnutls_session
 				GNUTLS_HANDSHAKE_CLIENT_HELLO,
 				MANDATORY_PACKET);
       STATE = STATE1;
-      IMED_RET ("recv hello", ret);
+      IMED_RET ("recv hello", ret, 1);
 
     case STATE2:
       ret = _gnutls_send_hello (session, AGAIN (STATE2));
       STATE = STATE2;
-      IMED_RET ("send hello", ret);
+      IMED_RET ("send hello", ret, 0);
 
     case STATE70:
       if (session->security_parameters.extensions.do_send_supplemental)
 	{
 	  ret = _gnutls_send_supplemental (session, AGAIN (STATE70));
 	  STATE = STATE70;
-	  IMED_RET ("send supplemental data", ret);
+	  IMED_RET ("send supplemental data", ret, 0);
 	}
 
       /* SEND CERTIFICATE + KEYEXCHANGE + CERTIFICATE_REQUEST */
@@ -2829,14 +2939,14 @@ _gnutls_handshake_server (gnutls_session
       if (session->internals.resumed == RESUME_FALSE)
 	ret = _gnutls_send_server_certificate (session, AGAIN (STATE3));
       STATE = STATE3;
-      IMED_RET ("send server certificate", ret);
+      IMED_RET ("send server certificate", ret, 0);
 
     case STATE4:
       /* send server key exchange (A) */
       if (session->internals.resumed == RESUME_FALSE)
 	ret = _gnutls_send_server_kx_message (session, AGAIN (STATE4));
       STATE = STATE4;
-      IMED_RET ("send server kx", ret);
+      IMED_RET ("send server kx", ret, 0);
 
     case STATE5:
       /* Send certificate request - if requested to */
@@ -2844,7 +2954,7 @@ _gnutls_handshake_server (gnutls_session
 	ret =
 	  _gnutls_send_server_certificate_request (session, AGAIN (STATE5));
       STATE = STATE5;
-      IMED_RET ("send server cert request", ret);
+      IMED_RET ("send server cert request", ret, 0);
 
     case STATE6:
       /* send the server hello done */
@@ -2854,14 +2964,14 @@ _gnutls_handshake_server (gnutls_session
 					GNUTLS_HANDSHAKE_SERVER_HELLO_DONE,
 					AGAIN (STATE6));
       STATE = STATE6;
-      IMED_RET ("send server hello done", ret);
+      IMED_RET ("send server hello done", ret, 0);
 
     case STATE71:
       if (session->security_parameters.extensions.do_recv_supplemental)
 	{
 	  ret = _gnutls_recv_supplemental (session);
 	  STATE = STATE71;
-	  IMED_RET ("recv client supplemental", ret);
+	  IMED_RET ("recv client supplemental", ret, 1);
 	}
 
       /* RECV CERTIFICATE + KEYEXCHANGE + CERTIFICATE_VERIFY */
@@ -2870,21 +2980,21 @@ _gnutls_handshake_server (gnutls_session
       if (session->internals.resumed == RESUME_FALSE)	/* if we are not resuming */
 	ret = _gnutls_recv_client_certificate (session);
       STATE = STATE7;
-      IMED_RET ("recv client certificate", ret);
+      IMED_RET ("recv client certificate", ret, 1);
 
     case STATE8:
       /* receive the client key exchange message */
       if (session->internals.resumed == RESUME_FALSE)	/* if we are not resuming */
 	ret = _gnutls_recv_client_kx_message (session);
       STATE = STATE8;
-      IMED_RET ("recv client kx", ret);
+      IMED_RET ("recv client kx", ret, 1);
 
     case STATE9:
       /* receive the client certificate verify message */
       if (session->internals.resumed == RESUME_FALSE)	/* if we are not resuming */
 	ret = _gnutls_recv_client_certificate_verify_message (session);
       STATE = STATE9;
-      IMED_RET ("recv client certificate verify", ret);
+      IMED_RET ("recv client certificate verify", ret, 1);
 
       STATE = STATE0;		/* finished thus clear session */
     default:
@@ -2908,10 +3018,10 @@ _gnutls_handshake_common (gnutls_session
       /* if we are a client resuming - or we are a server not resuming */
 
       ret = _gnutls_recv_handshake_final (session, TRUE);
-      IMED_RET ("recv handshake final", ret);
+      IMED_RET ("recv handshake final", ret, 1);
 
       ret = _gnutls_send_handshake_final (session, FALSE);
-      IMED_RET ("send handshake final", ret);
+      IMED_RET ("send handshake final", ret, 0);
 
       /* only store if we are not resuming */
       if (session->security_parameters.entity == GNUTLS_SERVER)
@@ -2924,10 +3034,10 @@ _gnutls_handshake_common (gnutls_session
     {				/* if we are a client not resuming - or we are a server resuming */
 
       ret = _gnutls_send_handshake_final (session, TRUE);
-      IMED_RET ("send handshake final 2", ret);
+      IMED_RET ("send handshake final 2", ret, 0);
 
       ret = _gnutls_recv_handshake_final (session, FALSE);
-      IMED_RET ("recv handshake final 2", ret);
+      IMED_RET ("recv handshake final 2", ret, 1);
     }
 
   /* clear handshake buffer */
diff -up gnutls-2.8.5/lib/gnutls_handshake.h.tls12 gnutls-2.8.5/lib/gnutls_handshake.h
--- gnutls-2.8.5/lib/gnutls_handshake.h.tls12	2009-11-02 11:30:39.000000000 +0100
+++ gnutls-2.8.5/lib/gnutls_handshake.h	2012-04-27 17:16:04.330095000 +0200
@@ -53,6 +53,8 @@ int _gnutls_server_select_suite (gnutls_
 int _gnutls_negotiate_version( gnutls_session_t session, gnutls_protocol_t adv_version);
 int _gnutls_user_hello_func( gnutls_session, gnutls_protocol_t adv_version);
 
+void _gnutls_handshake_hash_buffers_clear (gnutls_session_t session);
+
 #define STATE session->internals.handshake_state
 /* This returns true if we have got there
  * before (and not finished due to an interrupt).
diff -up gnutls-2.8.5/lib/gnutls_hash_int.c.tls12 gnutls-2.8.5/lib/gnutls_hash_int.c
--- gnutls-2.8.5/lib/gnutls_hash_int.c.tls12	2009-11-02 11:30:39.000000000 +0100
+++ gnutls-2.8.5/lib/gnutls_hash_int.c	2012-04-27 17:16:04.330095000 +0200
@@ -77,6 +77,7 @@ _gnutls_hash_init (digest_hd_st * dig, g
 	  gnutls_assert ();
 	  return GNUTLS_E_HASH_FAILED;
 	}
+      dig->active = 1;
       return 0;
     }
 
@@ -89,6 +90,7 @@ _gnutls_hash_init (digest_hd_st * dig, g
       return result;
     }
 
+  dig->active = 1;
   return 0;
 }
 
@@ -119,10 +121,10 @@ _gnutls_hash_copy (digest_hd_st * dst, d
 {
   int result;
 
+  memset(dst, 0, sizeof(*dst));
   dst->algorithm = src->algorithm;
-  dst->key = NULL;		/* it's a hash anyway */
-  dst->keysize = 0;
   dst->registered = src->registered;
+  dst->active = 1;
 
   if (src->registered)
     {
@@ -165,7 +167,14 @@ _gnutls_hash_output (digest_hd_st * hand
 void
 _gnutls_hash_deinit (digest_hd_st * handle, void *digest)
 {
-  _gnutls_hash_output (handle, digest);
+  if (handle->active != 1) {
+    return;
+  }
+
+  if (digest != NULL)
+    _gnutls_hash_output (handle, digest);
+
+  handle->active = 0;
 
   if (handle->registered && handle->hd.rh.ctx != NULL)
     {
@@ -269,6 +278,7 @@ _gnutls_hmac_init (digest_hd_st * dig, g
 	  return GNUTLS_E_HASH_FAILED;
 	}
 
+      dig->active = 1;
       return 0;
     }
 
@@ -283,6 +293,7 @@ _gnutls_hmac_init (digest_hd_st * dig, g
 
   _gnutls_mac_ops.setkey (dig->hd.gc, key, keylen);
 
+  dig->active = 1;
   return 0;
 }
 
@@ -323,8 +334,14 @@ _gnutls_hmac_output (digest_hd_st * hand
 void
 _gnutls_hmac_deinit (digest_hd_st * handle, void *digest)
 {
-  _gnutls_hmac_output (handle, digest);
+  if (handle->active != 1) {
+    return;
+  }
+
+  if (digest)
+    _gnutls_hmac_output (handle, digest);
 
+  handle->active = 0;
   if (handle->registered && handle->hd.rh.ctx != NULL)
     {
       handle->hd.rh.cc->deinit (handle->hd.rh.ctx);
@@ -398,6 +415,7 @@ _gnutls_mac_deinit_ssl3 (digest_hd_st *
   if (padsize == 0)
     {
       gnutls_assert ();
+      _gnutls_hash_deinit (handle, NULL);
       return;
     }
 
@@ -407,6 +425,7 @@ _gnutls_mac_deinit_ssl3 (digest_hd_st *
   if (rc < 0)
     {
       gnutls_assert ();
+      _gnutls_hash_deinit (handle, NULL);
       return;
     }
 
diff -up gnutls-2.8.5/lib/gnutls_hash_int.h.tls12 gnutls-2.8.5/lib/gnutls_hash_int.h
--- gnutls-2.8.5/lib/gnutls_hash_int.h.tls12	2009-11-02 11:30:39.000000000 +0100
+++ gnutls-2.8.5/lib/gnutls_hash_int.h	2012-04-27 17:16:04.331095022 +0200
@@ -52,6 +52,7 @@ typedef struct
   gnutls_mac_algorithm_t algorithm;
   const void *key;
   int keysize;
+  int active;
 } digest_hd_st;
 
 int _gnutls_hmac_init (digest_hd_st*, gnutls_mac_algorithm_t algorithm,
diff -up gnutls-2.8.5/lib/gnutls_int.h.tls12 gnutls-2.8.5/lib/gnutls_int.h
--- gnutls-2.8.5/lib/gnutls_int.h.tls12	2012-04-27 17:16:04.307094489 +0200
+++ gnutls-2.8.5/lib/gnutls_int.h	2012-04-30 16:48:28.661134165 +0200
@@ -171,6 +171,7 @@ typedef enum extensions_t
   GNUTLS_EXTENSION_OPAQUE_PRF_INPUT = ENABLE_OPRFI,
 #endif
   GNUTLS_EXTENSION_SRP = 12,
+  GNUTLS_EXTENSION_SIGNATURE_ALGORITHMS = 13,
   GNUTLS_EXTENSION_INNER_APPLICATION = 37703,
   GNUTLS_EXTENSION_SAFE_RENEGOTIATION = 65281,	/* aka: 0xff01 */
 } extensions_t;
@@ -196,6 +197,12 @@ typedef enum content_type_t
 #define GNUTLS_PK_ANY (gnutls_pk_algorithm_t)-1
 #define GNUTLS_PK_NONE (gnutls_pk_algorithm_t)-2
 
+typedef enum
+{
+  HANDSHAKE_MAC_TYPE_10=1,
+  HANDSHAKE_MAC_TYPE_12
+} handshake_mac_type_t;
+
 /* Store & Retrieve functions defines: 
  */
 
@@ -209,7 +216,6 @@ typedef struct auth_cred_st
   struct auth_cred_st *next;
 } auth_cred_st;
 
-
 struct gnutls_key_st
 {
   /* For DH KX */
@@ -269,6 +275,12 @@ typedef struct
   uint8_t suite[2];
 } cipher_suite_st;
 
+typedef struct
+{
+  uint8_t hash_algorithm;
+  uint8_t sign_algorithm; /* pk algorithm actually */
+} sign_algorithm_st;
+
 /* This structure holds parameters got from TLS extension
  * mechanism. (some extensions may hold parameters in auth_info_t
  * structures also - see SRP).
@@ -282,6 +294,7 @@ typedef struct
 } server_name_st;
 
 #define MAX_SERVER_NAME_EXTENSIONS 3
+#define MAX_SIGNATURE_ALGORITHMS 16
 
 #define MAX_VERIFY_DATA_SIZE 36 /* in SSL 3.0, 12 in TLS 1.0 */
 
@@ -296,6 +309,10 @@ typedef struct
 
   opaque srp_username[MAX_SRP_USERNAME + 1];
 
+  /* TLS 1.2 signature algorithms */
+  gnutls_sign_algorithm_t sign_algorithms[MAX_SIGNATURE_ALGORITHMS];
+  uint16_t sign_algorithms_size;
+
   /* TLS/IA data. */
   int gnutls_ia_enable, gnutls_ia_peer_enable;
   int gnutls_ia_allowskip, gnutls_ia_peer_allowskip;
@@ -357,6 +374,7 @@ typedef struct
   gnutls_cipher_algorithm_t write_bulk_cipher_algorithm;
   gnutls_mac_algorithm_t write_mac_algorithm;
   gnutls_compression_method_t write_compression_algorithm;
+  handshake_mac_type_t handshake_mac_handle_type; /* one of HANDSHAKE_TYPE_10 and HANDSHAKE_TYPE_12 */
 
   /* this is the ciphersuite we are going to use 
    * moved here from internals in order to be restored
@@ -435,6 +453,7 @@ struct gnutls_priority_st
   priority_st compression;
   priority_st protocol;
   priority_st cert_type;
+  priority_st sign_algo;
 
   /* to disable record padding */
   int no_padding:1;
@@ -473,14 +492,26 @@ typedef struct
   gnutls_handshake_description_t recv_type;
 } handshake_header_buffer_st;
 
+
 typedef struct
 {
   gnutls_buffer application_data_buffer;	/* holds data to be delivered to application layer */
   gnutls_buffer handshake_hash_buffer;	/* used to keep the last received handshake 
 					 * message */
-  digest_hd_st handshake_mac_handle_sha;	/* hash of the handshake messages */
-  digest_hd_st handshake_mac_handle_md5;	/* hash of the handshake messages */
-  int handshake_mac_handle_init; /* 1 when the previous two were initialized */
+  union
+    {
+      struct 
+        {
+          digest_hd_st sha;	/* hash of the handshake messages */
+          digest_hd_st md5;	/* hash of the handshake messages */
+        } tls10;
+      struct
+        {
+          digest_hd_st sha1;	/* hash of the handshake messages for TLS 1.2+ */
+          digest_hd_st sha256;	/* hash of the handshake messages for TLS 1.2+ */
+        } tls12;
+    } handshake_mac_handle;
+  int handshake_mac_handle_init; /* 1 when the previous union and type were initialized */
 
   gnutls_buffer handshake_data_buffer;	/* this is a buffer that holds the current handshake message */
   gnutls_buffer ia_data_buffer;	/* holds inner application data (TLS/IA) */
diff -up gnutls-2.8.5/lib/gnutls_pk.c.tls12 gnutls-2.8.5/lib/gnutls_pk.c
--- gnutls-2.8.5/lib/gnutls_pk.c.tls12	2009-07-22 20:26:40.000000000 +0200
+++ gnutls-2.8.5/lib/gnutls_pk.c	2012-04-30 15:33:56.567215852 +0200
@@ -500,8 +500,8 @@ _gnutls_dsa_verify (const gnutls_datum_t
     pk_params.params[i] = params[i];
   pk_params.params_nr = params_len;
 
-  if (vdata->size != 20)
-    {				/* sha-1 only */
+  if (vdata->size < 20)
+    {				/* SHA1 or better only */
       gnutls_assert ();
       return GNUTLS_E_PK_SIG_VERIFY_FAILED;
     }
diff -up gnutls-2.8.5/lib/gnutls_priority.c.tls12 gnutls-2.8.5/lib/gnutls_priority.c
--- gnutls-2.8.5/lib/gnutls_priority.c.tls12	2012-04-27 17:16:04.307094489 +0200
+++ gnutls-2.8.5/lib/gnutls_priority.c	2012-04-30 15:36:14.881288696 +0200
@@ -338,6 +338,27 @@ static const int comp_priority[] = {
   0
 };
 
+static const int sign_priority_default[] = {
+  GNUTLS_SIGN_RSA_SHA1,
+  GNUTLS_SIGN_DSA_SHA1,
+  GNUTLS_SIGN_RSA_SHA256,
+  GNUTLS_SIGN_RSA_SHA384,
+  GNUTLS_SIGN_RSA_SHA512,
+  0
+};
+
+static const int sign_priority_secure128[] = {
+  GNUTLS_SIGN_RSA_SHA256,
+  GNUTLS_SIGN_RSA_SHA384,
+  GNUTLS_SIGN_RSA_SHA512,
+  GNUTLS_SIGN_DSA_SHA1,
+  0
+};
+
+static const int sign_priority_secure256[] = {
+  GNUTLS_SIGN_RSA_SHA512,
+  0
+};
 
 static const int mac_priority_performance[] = {
   GNUTLS_MAC_MD5,
@@ -345,7 +366,9 @@ static const int mac_priority_performanc
   0
 };
 
+
 static const int mac_priority_secure[] = {
+  GNUTLS_MAC_SHA256,
   GNUTLS_MAC_SHA1,
   GNUTLS_MAC_MD5,
   0
@@ -516,7 +539,7 @@ gnutls_priority_set (gnutls_session_t se
  * Namespace concern:
  * To avoid collisions in order to specify a compression algorithm in
  * this string you have to prefix it with "COMP-", protocol versions
- * with "VERS-" and certificate types with "CTYPE-". All other
+ * with "VERS-", signature algorithms with "SIGN-" and certificate types with "CTYPE-". All other
  * algorithms don't need a prefix.
  *
  * Examples:
@@ -574,6 +597,7 @@ gnutls_priority_init (gnutls_priority_t
       _set_priority (&(*priority_cache)->protocol, protocol_priority);
       _set_priority (&(*priority_cache)->compression, comp_priority);
       _set_priority (&(*priority_cache)->cert_type, cert_type_priority);
+      _set_priority (&(*priority_cache)->sign_algo, sign_priority_default);
       i = 0;
     }
   else
@@ -589,12 +613,14 @@ gnutls_priority_init (gnutls_priority_t
 			 cipher_priority_performance);
 	  _set_priority (&(*priority_cache)->kx, kx_priority_performance);
 	  _set_priority (&(*priority_cache)->mac, mac_priority_performance);
+          _set_priority (&(*priority_cache)->sign_algo, sign_priority_default);
 	}
       else if (strcasecmp (broken_list[i], "NORMAL") == 0)
 	{
 	  _set_priority (&(*priority_cache)->cipher, cipher_priority_normal);
 	  _set_priority (&(*priority_cache)->kx, kx_priority_secure);
 	  _set_priority (&(*priority_cache)->mac, mac_priority_secure);
+          _set_priority (&(*priority_cache)->sign_algo, sign_priority_default);
 	}
       else if (strcasecmp (broken_list[i], "SECURE256") == 0
 	       || strcasecmp (broken_list[i], "SECURE") == 0)
@@ -603,6 +629,7 @@ gnutls_priority_init (gnutls_priority_t
 			 cipher_priority_secure256);
 	  _set_priority (&(*priority_cache)->kx, kx_priority_secure);
 	  _set_priority (&(*priority_cache)->mac, mac_priority_secure);
+          _set_priority (&(*priority_cache)->sign_algo, sign_priority_secure256);
 	}
       else if (strcasecmp (broken_list[i], "SECURE128") == 0)
 	{
@@ -610,12 +637,14 @@ gnutls_priority_init (gnutls_priority_t
 			 cipher_priority_secure128);
 	  _set_priority (&(*priority_cache)->kx, kx_priority_secure);
 	  _set_priority (&(*priority_cache)->mac, mac_priority_secure);
+          _set_priority (&(*priority_cache)->sign_algo, sign_priority_secure128);
 	}
       else if (strcasecmp (broken_list[i], "EXPORT") == 0)
 	{
 	  _set_priority (&(*priority_cache)->cipher, cipher_priority_export);
 	  _set_priority (&(*priority_cache)->kx, kx_priority_export);
 	  _set_priority (&(*priority_cache)->mac, mac_priority_secure);
+          _set_priority (&(*priority_cache)->sign_algo, sign_priority_default);
 	}			/* now check if the element is something like -ALGO */
       else if (broken_list[i][0] == '!' || broken_list[i][0] == '+'
 	       || broken_list[i][0] == '-')
@@ -640,6 +669,8 @@ gnutls_priority_init (gnutls_priority_t
 		   gnutls_protocol_get_id (&broken_list[i][6])) !=
 		  GNUTLS_VERSION_UNKNOWN)
 		fn (&(*priority_cache)->protocol, algo);
+              else
+                goto error;
 	    }			/* now check if the element is something like -ALGO */
 	  else if (strncasecmp (&broken_list[i][1], "COMP-", 5) == 0)
 	    {
@@ -647,6 +678,8 @@ gnutls_priority_init (gnutls_priority_t
 		   gnutls_compression_get_id (&broken_list[i][6])) !=
 		  GNUTLS_COMP_UNKNOWN)
 		fn (&(*priority_cache)->compression, algo);
+              else
+                goto error;
 	    }			/* now check if the element is something like -ALGO */
 	  else if (strncasecmp (&broken_list[i][1], "CTYPE-", 6) == 0)
 	    {
@@ -654,6 +687,17 @@ gnutls_priority_init (gnutls_priority_t
 		   gnutls_certificate_type_get_id (&broken_list[i][7])) !=
 		  GNUTLS_CRT_UNKNOWN)
 		fn (&(*priority_cache)->cert_type, algo);
+              else
+                goto error;
+	    }			/* now check if the element is something like -ALGO */
+	  else if (strncasecmp (&broken_list[i][1], "SIGN-", 5) == 0)
+	    {
+	      if ((algo =
+		   gnutls_sign_get_id (&broken_list[i][6])) !=
+		  GNUTLS_SIGN_UNKNOWN)
+		fn (&(*priority_cache)->sign_algo, algo);
+              else
+                goto error;
 	    }			/* now check if the element is something like -ALGO */
 	  else
 	    goto error;
@@ -664,8 +708,11 @@ gnutls_priority_init (gnutls_priority_t
 	    (*priority_cache)->no_padding = 1;
 	  else if (strcasecmp (&broken_list[i][1],
 			       "VERIFY_ALLOW_SIGN_RSA_MD5") == 0)
-	    (*priority_cache)->additional_verify_flags |=
-	      GNUTLS_VERIFY_ALLOW_SIGN_RSA_MD5;
+            {
+  	      prio_add (&(*priority_cache)->sign_algo, GNUTLS_SIGN_RSA_MD5);
+	      (*priority_cache)->additional_verify_flags |=
+	        GNUTLS_VERIFY_ALLOW_SIGN_RSA_MD5;
+            }
 	  else if (strcasecmp (&broken_list[i][1],
 			       "SSL3_RECORD_VERSION") == 0)
 	    (*priority_cache)->ssl3_record_version = 1;
diff -up gnutls-2.8.5/lib/gnutls_sig.c.tls12 gnutls-2.8.5/lib/gnutls_sig.c
--- gnutls-2.8.5/lib/gnutls_sig.c.tls12	2009-11-02 11:30:39.000000000 +0100
+++ gnutls-2.8.5/lib/gnutls_sig.c	2012-05-03 15:00:29.289576220 +0200
@@ -26,6 +26,7 @@
 #include <gnutls_errors.h>
 #include <x509_b64.h>
 #include <auth_cert.h>
+#include <gnutls_algorithms.h>
 #include <gnutls_cert.h>
 #include <gnutls_datum.h>
 #include <gnutls_mpi.h>
@@ -35,6 +36,9 @@
 #include <gnutls_buffers.h>
 #include <gnutls_sig.h>
 #include <gnutls_kx.h>
+#include <libtasn1.h>
+#include <ext_signature.h>
+#include <gnutls_state.h>
 
 static int
 _gnutls_tls_sign (gnutls_session_t session,
@@ -42,102 +46,106 @@ _gnutls_tls_sign (gnutls_session_t sessi
 		  const gnutls_datum_t * hash_concat,
 		  gnutls_datum_t * signature);
 
+/* While this is currently equal to the length of RSA/SHA512
+ * signature, it should also be sufficient for DSS signature and any
+ * other RSA signatures including one with the old MD5/SHA1-combined
+ * format.
+ */
+#define MAX_SIG_SIZE 19 + MAX_HASH_SIZE
 
-/* Generates a signature of all the previous sent packets in the 
- * handshake procedure. (20040227: now it works for SSL 3.0 as well)
+/* Create a DER-encoded value as a opaque signature when RSA is used.
+ * See RFC 5246 DigitallySigned for the actual format.
  */
-int
-_gnutls_tls_sign_hdata (gnutls_session_t session,
-			gnutls_cert * cert, gnutls_privkey * pkey,
+static int
+_gnutls_rsa_encode_sig (gnutls_mac_algorithm_t algo,
+			const gnutls_datum_t * hash,
 			gnutls_datum_t * signature)
 {
-  gnutls_datum_t dconcat;
-  int ret;
-  opaque concat[36];
-  digest_hd_st td_md5;
-  digest_hd_st td_sha;
-  gnutls_protocol_t ver = gnutls_protocol_get_version (session);
+  ASN1_TYPE di;
+  const char *oid;
+  int result, signature_size;
 
-  ret =
-    _gnutls_hash_copy (&td_sha, &session->internals.handshake_mac_handle_sha);
-  if (ret < 0)
+  oid = _gnutls_x509_mac_to_oid (algo);
+  if (!oid)
     {
       gnutls_assert ();
-      return ret;
+      return GNUTLS_E_UNKNOWN_HASH_ALGORITHM;
     }
 
-  if (ver == GNUTLS_SSL3)
+  if ((result = asn1_create_element
+       (_gnutls_get_gnutls_asn (), "GNUTLS.DigestInfo", &di)) != ASN1_SUCCESS)
     {
-      ret = _gnutls_generate_master (session, 1);
-      if (ret < 0)
-	{
-	  gnutls_assert ();
-	  return ret;
-	}
-
-      _gnutls_mac_deinit_ssl3_handshake (&td_sha, &concat[16],
-					 session->security_parameters.
-					 master_secret, GNUTLS_MASTER_SIZE);
+      gnutls_assert ();
+      return _gnutls_asn2err (result);
     }
-  else
-    _gnutls_hash_deinit (&td_sha, &concat[16]);
 
-  switch (cert->subject_pk_algorithm)
+  if ((result = asn1_write_value (di, "digestAlgorithm.algorithm",
+				  oid, strlen (oid))) != ASN1_SUCCESS)
     {
-    case GNUTLS_PK_RSA:
-      ret =
-	_gnutls_hash_copy (&td_md5,
-			   &session->internals.handshake_mac_handle_md5);
-      if (ret < 0)
-	{
-	  gnutls_assert ();
-	  return ret;
-	}
-
-      if (ver == GNUTLS_SSL3)
-	_gnutls_mac_deinit_ssl3_handshake (&td_md5, concat,
-					   session->security_parameters.
-					   master_secret, GNUTLS_MASTER_SIZE);
-      else
-	_gnutls_hash_deinit (&td_md5, concat);
+      gnutls_assert ();
+      asn1_delete_structure (&di);
+      return _gnutls_asn2err (result);
+    }
 
-      dconcat.data = concat;
-      dconcat.size = 36;
-      break;
-    case GNUTLS_PK_DSA:
-      dconcat.data = &concat[16];
-      dconcat.size = 20;
-      break;
+  /* Use NULL parameters. */
+  if ((result = asn1_write_value (di, "digestAlgorithm.parameters",
+				  "\x05\x00", 2)) != ASN1_SUCCESS)
+    {
+      gnutls_assert ();
+      asn1_delete_structure (&di);
+      return _gnutls_asn2err (result);
+    }
 
-    default:
+  if ((result = asn1_write_value (di, "digest",
+				  hash->data, hash->size)) != ASN1_SUCCESS)
+    {
       gnutls_assert ();
-      return GNUTLS_E_INTERNAL_ERROR;
+      asn1_delete_structure (&di);
+      return _gnutls_asn2err (result);
     }
-  ret = _gnutls_tls_sign (session, cert, pkey, &dconcat, signature);
-  if (ret < 0)
+
+  signature_size = signature->size;
+  result = asn1_der_coding (di, "", signature->data, &signature_size, NULL);
+  asn1_delete_structure (&di);
+
+  if (result != ASN1_SUCCESS)
     {
       gnutls_assert ();
+      return _gnutls_asn2err (result);
     }
 
-  return ret;
+  signature->size = signature_size;
+
+  return 0;
 }
 
 
+
 /* Generates a signature of all the random data and the parameters.
  * Used in DHE_* ciphersuites.
  */
 int
-_gnutls_tls_sign_params (gnutls_session_t session, gnutls_cert * cert,
+_gnutls_handshake_sign_data (gnutls_session_t session, gnutls_cert * cert,
 			 gnutls_privkey * pkey, gnutls_datum_t * params,
-			 gnutls_datum_t * signature)
+			 gnutls_datum_t * signature,
+			 gnutls_sign_algorithm_t * sign_algo)
 {
   gnutls_datum_t dconcat;
   int ret;
   digest_hd_st td_sha;
-  opaque concat[36];
+  opaque concat[MAX_SIG_SIZE];
   gnutls_protocol_t ver = gnutls_protocol_get_version (session);
+  gnutls_digest_algorithm_t hash_algo;
 
-  ret = _gnutls_hash_init (&td_sha, GNUTLS_MAC_SHA1);
+  *sign_algo = _gnutls_session_get_sign_algo(session, cert->subject_pk_algorithm,
+					    &hash_algo);
+  if (*sign_algo == GNUTLS_SIGN_UNKNOWN)
+    {
+      gnutls_assert ();
+      return GNUTLS_E_UNKNOWN_PK_ALGORITHM;
+    }
+
+  ret = _gnutls_hash_init (&td_sha, hash_algo);
   if (ret < 0)
     {
       gnutls_assert ();
@@ -153,7 +161,7 @@ _gnutls_tls_sign_params (gnutls_session_
   switch (cert->subject_pk_algorithm)
     {
     case GNUTLS_PK_RSA:
-      if (ver < GNUTLS_TLS1_2)
+      if (!_gnutls_version_has_selectable_prf(ver))
 	{
 	  digest_hd_st td_md5;
 
@@ -173,29 +181,36 @@ _gnutls_tls_sign_params (gnutls_session_
 	  _gnutls_hash_deinit (&td_md5, concat);
 	  _gnutls_hash_deinit (&td_sha, &concat[16]);
 
+	  dconcat.data = concat;
 	  dconcat.size = 36;
 	}
       else
-	{
-#if 1
-	  /* Use NULL parameters. */
-	  memcpy (concat,
-		  "\x30\x21\x30\x09\x06\x05\x2b\x0e\x03\x02\x1a\x05\x00\x04\x14",
-		  15);
-	  _gnutls_hash_deinit (&td_sha, &concat[15]);
-	  dconcat.size = 35;
-#else
-	  /* No parameters field. */
-	  memcpy (concat,
-		  "\x30\x1f\x30\x07\x06\x05\x2b\x0e\x03\x02\x1a\x04\x14", 13);
-	  _gnutls_hash_deinit (&td_sha, &concat[13]);
-	  dconcat.size = 33;
-#endif
+	{ /* TLS 1.2 way */
+	  gnutls_datum_t hash;
+
+	  _gnutls_hash_deinit (&td_sha, concat);
+
+	  hash.data = concat;
+	  hash.size = _gnutls_hash_get_algo_len (hash_algo);
+	  dconcat.data = concat;
+	  dconcat.size = sizeof concat;
+
+	  ret = _gnutls_rsa_encode_sig (hash_algo, &hash, &dconcat);
+	  if (ret < 0)
+	    {
+	      gnutls_assert();
+	      return ret;
+            }
 	}
-      dconcat.data = concat;
       break;
     case GNUTLS_PK_DSA:
       _gnutls_hash_deinit (&td_sha, concat);
+
+      if (hash_algo != GNUTLS_DIG_SHA1)
+        {
+          gnutls_assert();
+          return GNUTLS_E_INTERNAL_ERROR;
+        }
       dconcat.data = concat;
       dconcat.size = 20;
       break;
@@ -297,7 +312,8 @@ _gnutls_tls_sign (gnutls_session_t sessi
 static int
 _gnutls_verify_sig (gnutls_cert * cert,
 		    const gnutls_datum_t * hash_concat,
-		    gnutls_datum_t * signature, size_t sha1pos)
+		    gnutls_datum_t * signature, size_t sha1pos,
+		    gnutls_pk_algorithm_t pk_algo)
 {
   int ret;
   gnutls_datum_t vdata;
@@ -320,7 +336,9 @@ _gnutls_verify_sig (gnutls_cert * cert,
 	  return GNUTLS_E_KEY_USAGE_VIOLATION;
 	}
 
-  switch (cert->subject_pk_algorithm)
+  if (pk_algo == GNUTLS_PK_UNKNOWN)
+    pk_algo = cert->subject_pk_algorithm;
+  switch (pk_algo)
     {
     case GNUTLS_PK_RSA:
 
@@ -339,7 +357,7 @@ _gnutls_verify_sig (gnutls_cert * cert,
     case GNUTLS_PK_DSA:
 
       vdata.data = &hash_concat->data[sha1pos];
-      vdata.size = 20;		/* sha1 */
+      vdata.size = hash_concat->size - sha1pos;
 
       /* verify signature */
       if ((ret = _gnutls_dsa_verify (&vdata, signature, cert->params,
@@ -362,22 +380,196 @@ _gnutls_verify_sig (gnutls_cert * cert,
 }
 
 
+/* Generates a signature of all the random data and the parameters.
+ * Used in DHE_* ciphersuites.
+ */
+int
+_gnutls_handshake_verify_data (gnutls_session_t session, gnutls_cert * cert,
+			   const gnutls_datum_t * params,
+			   gnutls_datum_t * signature,
+			   gnutls_sign_algorithm_t algo)
+{
+  gnutls_datum_t dconcat;
+  int ret;
+  digest_hd_st td_md5;
+  digest_hd_st td_sha;
+  opaque concat[MAX_SIG_SIZE];
+  gnutls_protocol_t ver = gnutls_protocol_get_version (session);
+  gnutls_digest_algorithm_t hash_algo = GNUTLS_DIG_SHA1;
+
+  ret = _gnutls_session_sign_algo_enabled(session, algo);
+  if (ret < 0)
+    {
+      gnutls_assert();
+      return ret;
+    }
+
+  if (!_gnutls_version_has_selectable_prf (ver))
+    {
+      ret = _gnutls_hash_init (&td_md5, GNUTLS_MAC_MD5);
+      if (ret < 0)
+	{
+	  gnutls_assert ();
+	  return ret;
+	}
+
+      _gnutls_hash (&td_md5, session->security_parameters.client_random,
+		    GNUTLS_RANDOM_SIZE);
+      _gnutls_hash (&td_md5, session->security_parameters.server_random,
+		    GNUTLS_RANDOM_SIZE);
+      _gnutls_hash (&td_md5, params->data, params->size);
+    }
+
+  if (algo != GNUTLS_SIGN_UNKNOWN)
+    hash_algo = _gnutls_sign_get_hash_algorithm (algo);
+
+  ret = _gnutls_hash_init (&td_sha, hash_algo);
+  if (ret < 0)
+    {
+      gnutls_assert ();
+      if (!_gnutls_version_has_selectable_prf (ver))
+	_gnutls_hash_deinit (&td_md5, NULL);
+      return ret;
+    }
+
+  _gnutls_hash (&td_sha, session->security_parameters.client_random,
+		GNUTLS_RANDOM_SIZE);
+  _gnutls_hash (&td_sha, session->security_parameters.server_random,
+		GNUTLS_RANDOM_SIZE);
+  _gnutls_hash (&td_sha, params->data, params->size);
+
+  if (!_gnutls_version_has_selectable_prf (ver))
+    {
+      _gnutls_hash_deinit (&td_md5, concat);
+      _gnutls_hash_deinit (&td_sha, &concat[16]);
+      dconcat.data = concat;
+      dconcat.size = 36;
+    }
+  else
+    {
+      gnutls_datum_t hash;
+
+      _gnutls_hash_deinit (&td_sha, concat);
+
+      hash.data = concat;
+      hash.size = _gnutls_hash_get_algo_len (hash_algo);
+      dconcat.data = concat;
+      dconcat.size = sizeof concat;
+
+      ret = _gnutls_rsa_encode_sig (hash_algo, &hash, &dconcat);
+      if (ret < 0)
+        {
+          gnutls_assert();
+          return ret;
+        }
+    }
+
+  ret = _gnutls_verify_sig (cert, &dconcat, signature,
+			    dconcat.size - _gnutls_hash_get_algo_len (hash_algo),
+			    _gnutls_sign_get_pk_algorithm (algo));
+  if (ret < 0)
+    {
+      gnutls_assert ();
+      return ret;
+    }
+
+  return ret;
+
+}
+
+/* Client certificate verify calculations
+ */
+
+/* this is _gnutls_handshake_verify_cert_vrfy for TLS 1.2
+ */
+static int _gnutls_handshake_verify_cert_vrfy12 (gnutls_session_t session, gnutls_cert * cert,
+			  gnutls_datum_t * signature, gnutls_sign_algorithm_t sign_algo)
+{
+  int ret;
+  opaque concat[MAX_SIG_SIZE];
+  digest_hd_st td;
+  gnutls_datum_t dconcat;
+  gnutls_datum_t hash;
+  gnutls_sign_algorithm_t _sign_algo;
+  gnutls_digest_algorithm_t hash_algo;
+  digest_hd_st* handshake_td;
+
+  handshake_td = &session->internals.handshake_mac_handle.tls12.sha1;
+  hash_algo = handshake_td->algorithm;
+  _sign_algo = _gnutls_x509_pk_to_sign( cert->subject_pk_algorithm, hash_algo);
+
+  if (_sign_algo != sign_algo)
+    {
+      handshake_td = &session->internals.handshake_mac_handle.tls12.sha256;
+      hash_algo = handshake_td->algorithm;
+      _sign_algo = _gnutls_x509_pk_to_sign( cert->subject_pk_algorithm, hash_algo);
+      if (sign_algo != _sign_algo)
+        {
+          gnutls_assert();
+          return GNUTLS_E_UNSUPPORTED_SIGNATURE_ALGORITHM;
+        }
+    }
+
+  ret =
+    _gnutls_hash_copy (&td, handshake_td);
+  if (ret < 0)
+    {
+      gnutls_assert ();
+      return GNUTLS_E_HASH_FAILED;
+    }
+
+  _gnutls_hash_deinit (&td, concat);
+
+  hash.data = concat;
+  hash.size = _gnutls_hash_get_algo_len (hash_algo);
+
+  dconcat.data = concat;
+  dconcat.size = sizeof concat;
+
+  ret = _gnutls_rsa_encode_sig (hash_algo, &hash, &dconcat);
+  if (ret < 0)
+    {
+      gnutls_assert();
+      return ret;
+    }
+
+  ret = _gnutls_verify_sig (cert, &dconcat, signature, 0, cert->subject_pk_algorithm);
+  if (ret < 0)
+    {
+      gnutls_assert ();
+      return ret;
+    }
+
+  return ret;
+
+}
+
 /* Verifies a TLS signature (like the one in the client certificate
  * verify message). 
  */
 int
-_gnutls_verify_sig_hdata (gnutls_session_t session, gnutls_cert * cert,
-			  gnutls_datum_t * signature)
+_gnutls_handshake_verify_cert_vrfy (gnutls_session_t session, gnutls_cert * cert,
+			  gnutls_datum_t * signature, gnutls_sign_algorithm_t sign_algo)
 {
   int ret;
-  opaque concat[36];
+  opaque concat[MAX_SIG_SIZE];
   digest_hd_st td_md5;
   digest_hd_st td_sha;
   gnutls_datum_t dconcat;
   gnutls_protocol_t ver = gnutls_protocol_get_version (session);
 
+  if (session->security_parameters.handshake_mac_handle_type == HANDSHAKE_MAC_TYPE_12)
+    {
+      return _gnutls_handshake_verify_cert_vrfy12(session, cert, signature, sign_algo);
+    }
+  else if (session->security_parameters.handshake_mac_handle_type != HANDSHAKE_MAC_TYPE_10)
+    {
+      gnutls_assert();
+      return GNUTLS_E_INTERNAL_ERROR;
+    }
+
   ret =
-    _gnutls_hash_copy (&td_md5, &session->internals.handshake_mac_handle_md5);
+    _gnutls_hash_copy (&td_md5, &session->internals.handshake_mac_handle.tls10.md5);
   if (ret < 0)
     {
       gnutls_assert ();
@@ -385,7 +577,7 @@ _gnutls_verify_sig_hdata (gnutls_session
     }
 
   ret =
-    _gnutls_hash_copy (&td_sha, &session->internals.handshake_mac_handle_sha);
+    _gnutls_hash_copy (&td_sha, &session->internals.handshake_mac_handle.tls10.sha);
   if (ret < 0)
     {
       gnutls_assert ();
@@ -418,7 +610,7 @@ _gnutls_verify_sig_hdata (gnutls_session
   dconcat.data = concat;
   dconcat.size = 20 + 16;	/* md5+ sha */
 
-  ret = _gnutls_verify_sig (cert, &dconcat, signature, 16);
+  ret = _gnutls_verify_sig (cert, &dconcat, signature, 16, cert->subject_pk_algorithm);
   if (ret < 0)
     {
       gnutls_assert ();
@@ -429,85 +621,188 @@ _gnutls_verify_sig_hdata (gnutls_session
 
 }
 
-/* Generates a signature of all the random data and the parameters.
- * Used in DHE_* ciphersuites.
+/* the same as _gnutls_handshake_sign_cert_vrfy except that it is made for TLS 1.2
  */
-int
-_gnutls_verify_sig_params (gnutls_session_t session, gnutls_cert * cert,
-			   const gnutls_datum_t * params,
-			   gnutls_datum_t * signature)
+static int
+_gnutls_handshake_sign_cert_vrfy12 (gnutls_session_t session,
+				    gnutls_cert * cert, gnutls_privkey * pkey,
+				    gnutls_datum_t * signature)
 {
-  gnutls_datum_t dconcat;
+  gnutls_datum_t dconcat, hash;
   int ret;
-  digest_hd_st td_md5;
-  digest_hd_st td_sha;
-  opaque concat[36];
-  gnutls_protocol_t ver = gnutls_protocol_get_version (session);
-
-  if (ver < GNUTLS_TLS1_2)
+  opaque concat[MAX_SIG_SIZE];
+  digest_hd_st td;
+  gnutls_sign_algorithm_t sign_algo;
+  gnutls_digest_algorithm_t hash_algo;
+  digest_hd_st *handshake_td;
+
+  handshake_td = &session->internals.handshake_mac_handle.tls12.sha1;
+  hash_algo = handshake_td->algorithm;
+  sign_algo = _gnutls_x509_pk_to_sign (cert->subject_pk_algorithm, hash_algo);
+
+  /* The idea here is to try signing with the one of the algorithms
+   * that have been initiated at handshake (SHA1, SHA256). If they
+   * are not requested by peer... tough luck
+   */
+  ret = _gnutls_session_sign_algo_requested (session, sign_algo);
+  if (sign_algo == GNUTLS_SIGN_UNKNOWN || ret < 0)
     {
-      ret = _gnutls_hash_init (&td_md5, GNUTLS_MAC_MD5);
+      handshake_td = &session->internals.handshake_mac_handle.tls12.sha256;
+      hash_algo = handshake_td->algorithm;
+      sign_algo =
+	_gnutls_x509_pk_to_sign (cert->subject_pk_algorithm, hash_algo);
+      if (sign_algo == GNUTLS_SIGN_UNKNOWN)
+	{
+	  gnutls_assert ();
+	  return GNUTLS_E_UNSUPPORTED_SIGNATURE_ALGORITHM;
+	}
+
+      ret = _gnutls_session_sign_algo_requested (session, sign_algo);
       if (ret < 0)
 	{
 	  gnutls_assert ();
+	  _gnutls_x509_log
+	    ("Server did not allow either '%s' or '%s' for signing\n",
+	     gnutls_mac_get_name (hash_algo),
+	     gnutls_mac_get_name (session->internals.handshake_mac_handle.
+				  tls12.sha1.algorithm));
 	  return ret;
 	}
-
-      _gnutls_hash (&td_md5, session->security_parameters.client_random,
-		    GNUTLS_RANDOM_SIZE);
-      _gnutls_hash (&td_md5, session->security_parameters.server_random,
-		    GNUTLS_RANDOM_SIZE);
-      _gnutls_hash (&td_md5, params->data, params->size);
     }
 
-  ret = _gnutls_hash_init (&td_sha, GNUTLS_MAC_SHA1);
+  _gnutls_x509_log ("sign handshake cert vrfy: picked %s with %s\n",
+		    gnutls_sign_algorithm_get_name (sign_algo),
+		    gnutls_mac_get_name (hash_algo));
+
+  ret = _gnutls_hash_copy (&td, handshake_td);
   if (ret < 0)
     {
       gnutls_assert ();
-      if (ver < GNUTLS_TLS1_2)
-	_gnutls_hash_deinit (&td_md5, NULL);
       return ret;
     }
 
-  _gnutls_hash (&td_sha, session->security_parameters.client_random,
-		GNUTLS_RANDOM_SIZE);
-  _gnutls_hash (&td_sha, session->security_parameters.server_random,
-		GNUTLS_RANDOM_SIZE);
-  _gnutls_hash (&td_sha, params->data, params->size);
+  _gnutls_hash_deinit (&td, concat);
+
+  hash.data = concat;
+  hash.size = _gnutls_hash_get_algo_len (hash_algo);
+
+  dconcat.data = concat;
+  dconcat.size = sizeof concat;
 
-  if (ver < GNUTLS_TLS1_2)
+  ret = _gnutls_rsa_encode_sig (hash_algo, &hash, &dconcat);
+  if (ret < 0)
     {
-      _gnutls_hash_deinit (&td_md5, concat);
-      _gnutls_hash_deinit (&td_sha, &concat[16]);
-      dconcat.size = 36;
+      gnutls_assert();
+      return ret;
     }
-  else
+
+  ret = _gnutls_tls_sign (session, cert, pkey, &dconcat, signature);
+  if (ret < 0)
     {
-#if 1
-      /* Use NULL parameters. */
-      memcpy (concat,
-	      "\x30\x21\x30\x09\x06\x05\x2b\x0e\x03\x02\x1a\x05\x00\x04\x14",
-	      15);
-      _gnutls_hash_deinit (&td_sha, &concat[15]);
-      dconcat.size = 35;
-#else
-      /* No parameters field. */
-      memcpy (concat,
-	      "\x30\x1f\x30\x07\x06\x05\x2b\x0e\x03\x02\x1a\x04\x14", 13);
-      _gnutls_hash_deinit (&td_sha, &concat[13]);
-      dconcat.size = 33;
-#endif
+      gnutls_assert ();
+      return ret;
     }
 
-  dconcat.data = concat;
+  return sign_algo;
+}
+
+/* Generates a signature of all the previous sent packets in the 
+ * handshake procedure. 
+ * 20040227: now it works for SSL 3.0 as well
+ * 20091031: works for TLS 1.2 too!
+ *
+ * For TLS1.x, x<2 returns negative for failure and zero or unspecified for success.
+ * For TLS1.2 returns the signature algorithm used on success, or a negative value;
+ */
+int
+_gnutls_handshake_sign_cert_vrfy (gnutls_session_t session,
+				  gnutls_cert * cert, gnutls_privkey * pkey,
+				  gnutls_datum_t * signature)
+{
+  gnutls_datum_t dconcat;
+  int ret;
+  opaque concat[MAX_SIG_SIZE];
+  digest_hd_st td_md5;
+  digest_hd_st td_sha;
+  gnutls_protocol_t ver = gnutls_protocol_get_version (session);
 
-  ret = _gnutls_verify_sig (cert, &dconcat, signature, dconcat.size - 20);
+  if (session->security_parameters.handshake_mac_handle_type ==
+      HANDSHAKE_MAC_TYPE_12)
+    {
+      return _gnutls_handshake_sign_cert_vrfy12 (session, cert, pkey,
+						 signature);
+    }
+  else if (session->security_parameters.handshake_mac_handle_type !=
+	   HANDSHAKE_MAC_TYPE_10)
+    {
+      gnutls_assert ();
+      return GNUTLS_E_INTERNAL_ERROR;
+    }
+
+  ret =
+    _gnutls_hash_copy (&td_sha,
+		       &session->internals.handshake_mac_handle.tls10.sha);
   if (ret < 0)
     {
       gnutls_assert ();
       return ret;
     }
 
-  return ret;
+  if (ver == GNUTLS_SSL3)
+    {
+      ret = _gnutls_generate_master (session, 1);
+      if (ret < 0)
+	{
+	  gnutls_assert ();
+	  return ret;
+	}
+
+      _gnutls_mac_deinit_ssl3_handshake (&td_sha, &concat[16],
+					 session->
+					 security_parameters.master_secret,
+					 GNUTLS_MASTER_SIZE);
+    }
+  else
+    _gnutls_hash_deinit (&td_sha, &concat[16]);
+
+  switch (cert->subject_pk_algorithm)
+    {
+    case GNUTLS_PK_RSA:
+      ret =
+	_gnutls_hash_copy (&td_md5,
+			   &session->internals.handshake_mac_handle.tls10.
+			   md5);
+      if (ret < 0)
+	{
+	  gnutls_assert ();
+	  return ret;
+	}
+
+      if (ver == GNUTLS_SSL3)
+	_gnutls_mac_deinit_ssl3_handshake (&td_md5, concat,
+					   session->
+					   security_parameters.master_secret,
+					   GNUTLS_MASTER_SIZE);
+      else
+	_gnutls_hash_deinit (&td_md5, concat);
 
+      dconcat.data = concat;
+      dconcat.size = 36;
+      break;
+    case GNUTLS_PK_DSA:
+      dconcat.data = &concat[16];
+      dconcat.size = 20;
+      break;
+
+    default:
+      gnutls_assert ();
+      return GNUTLS_E_INTERNAL_ERROR;
+    }
+  ret = _gnutls_tls_sign (session, cert, pkey, &dconcat, signature);
+  if (ret < 0)
+    {
+      gnutls_assert ();
+    }
+
+  return ret;
 }
diff -up gnutls-2.8.5/lib/gnutls_sig.h.tls12 gnutls-2.8.5/lib/gnutls_sig.h
--- gnutls-2.8.5/lib/gnutls_sig.h.tls12	2009-06-02 20:59:32.000000000 +0200
+++ gnutls-2.8.5/lib/gnutls_sig.h	2012-04-30 16:36:33.592240022 +0200
@@ -25,24 +25,27 @@
 #ifndef GNUTLS_SIG_H
 # define GNUTLS_SIG_H
 
-int _gnutls_tls_sign_hdata (gnutls_session_t session,
+int _gnutls_handshake_sign_cert_vrfy (gnutls_session_t session,
 			    gnutls_cert * cert,
 			    gnutls_privkey * pkey,
 			    gnutls_datum_t * signature);
 
-int _gnutls_tls_sign_params (gnutls_session_t session,
+int _gnutls_handshake_sign_data (gnutls_session_t session,
 			     gnutls_cert * cert,
 			     gnutls_privkey * pkey,
 			     gnutls_datum_t * params,
-			     gnutls_datum_t * signature);
+			     gnutls_datum_t * signature,
+			     gnutls_sign_algorithm_t * algo);
 
-int _gnutls_verify_sig_hdata (gnutls_session_t session,
-			      gnutls_cert * cert, gnutls_datum_t * signature);
+int _gnutls_handshake_verify_cert_vrfy (gnutls_session_t session,
+			      gnutls_cert * cert, gnutls_datum_t * signature,
+			      gnutls_sign_algorithm_t);
 
-int _gnutls_verify_sig_params (gnutls_session_t session,
+int _gnutls_handshake_verify_data (gnutls_session_t session,
 			       gnutls_cert * cert,
 			       const gnutls_datum_t * params,
-			       gnutls_datum_t * signature);
+			       gnutls_datum_t * signature,
+			       gnutls_sign_algorithm_t algo);
 
 int _gnutls_sign (gnutls_pk_algorithm_t algo,
 		  bigint_t * params, int params_size,
diff -up gnutls-2.8.5/lib/gnutls_state.c.tls12 gnutls-2.8.5/lib/gnutls_state.c
--- gnutls-2.8.5/lib/gnutls_state.c.tls12	2012-04-27 17:16:04.309094534 +0200
+++ gnutls-2.8.5/lib/gnutls_state.c	2012-04-30 16:05:07.905139701 +0200
@@ -189,6 +189,7 @@ _gnutls_session_cert_type_supported (gnu
   return GNUTLS_E_UNSUPPORTED_CERTIFICATE_TYPE;
 }
 
+
 /* this function deinitializes all the internal parameters stored
  * in a session struct.
  */
@@ -201,6 +202,8 @@ deinit_internal_params (gnutls_session_t
   if (session->internals.params.free_rsa_params)
     gnutls_rsa_params_deinit (session->internals.params.rsa_params);
 
+  _gnutls_handshake_hash_buffers_clear(session);
+
   memset (&session->internals.params, 0, sizeof (session->internals.params));
 }
 
@@ -208,8 +211,8 @@ deinit_internal_params (gnutls_session_t
  * structure within the session, which depend on the current handshake.
  * This is used to allow further handshakes.
  */
-void
-_gnutls_handshake_internal_state_clear (gnutls_session_t session)
+static void
+_gnutls_handshake_internal_state_init (gnutls_session_t session)
 {
   session->internals.extensions_sent_size = 0;
 
@@ -232,6 +235,13 @@ _gnutls_handshake_internal_state_clear (
   session->internals.last_handshake_out = -1;
 
   session->internals.resumable = RESUME_TRUE;
+}
+
+void
+_gnutls_handshake_internal_state_clear (gnutls_session_t session)
+{
+  _gnutls_handshake_internal_state_init(session);
+
   _gnutls_free_datum (&session->internals.recv_buffer);
 
   deinit_internal_params (session);
@@ -337,7 +347,7 @@ gnutls_init (gnutls_session_t * session,
    * as NULL or 0. This is why calloc is used.
    */
 
-  _gnutls_handshake_internal_state_clear (*session);
+  _gnutls_handshake_internal_state_init (*session);
 
   /* emulate old gnutls behavior for old applications that do not use the priority_*
    * functions.
@@ -787,7 +797,7 @@ _gnutls_P_hash (gnutls_mac_algorithm_t a
 
   digest_hd_st td2;
   int i, times, how, blocksize, A_size;
-  opaque final[20], Atmp[MAX_SEED_SIZE];
+  opaque final[MAX_HASH_SIZE], Atmp[MAX_SEED_SIZE];
   int output_bytes, result;
 
   if (seed_size > MAX_SEED_SIZE || total_bytes <= 0)
@@ -905,10 +915,10 @@ _gnutls_PRF (gnutls_session_t session,
   memcpy (s_seed, label, label_size);
   memcpy (&s_seed[label_size], seed, seed_size);
 
-  if (ver >= GNUTLS_TLS1_2)
+  if (_gnutls_version_has_selectable_prf(ver))
     {
       result =
-	_gnutls_P_hash (GNUTLS_MAC_SHA1, secret, secret_size,
+	_gnutls_P_hash (GNUTLS_MAC_SHA256, secret, secret_size,
 			s_seed, s_seed_size, total_bytes, ret);
       if (result < 0)
 	{
@@ -1353,3 +1363,4 @@ gnutls_session_enable_compatibility_mode
 {
   gnutls_record_disable_padding (session);
 }
+
diff -up gnutls-2.8.5/lib/gnutls_state.h.tls12 gnutls-2.8.5/lib/gnutls_state.h
--- gnutls-2.8.5/lib/gnutls_state.h.tls12	2009-06-02 20:59:32.000000000 +0200
+++ gnutls-2.8.5/lib/gnutls_state.h	2012-04-30 16:05:07.905139701 +0200
@@ -41,7 +41,6 @@ void _gnutls_session_cert_type_set (gnut
 
 int _gnutls_session_cert_type_supported (gnutls_session_t,
 					 gnutls_certificate_type_t);
-
 int _gnutls_dh_set_secret_bits (gnutls_session_t session, unsigned bits);
 
 int _gnutls_dh_set_peer_public (gnutls_session_t session, bigint_t public);
diff -up gnutls-2.8.5/lib/gnutls_x509.c.tls12 gnutls-2.8.5/lib/gnutls_x509.c
--- gnutls-2.8.5/lib/gnutls_x509.c.tls12	2009-08-12 08:58:13.000000000 +0200
+++ gnutls-2.8.5/lib/gnutls_x509.c	2012-04-30 15:36:14.886288809 +0200
@@ -159,6 +159,14 @@ _gnutls_x509_cert_verify_peers (gnutls_s
 	  return ret;
 	}
 
+      
+      if (ret < 0)
+        {
+          gnutls_assert();
+          CLEAR_CERTS;
+          return ret;
+        }
+
       ret = check_bits (peer_certificate_list[i], cred->verify_bits);
       if (ret < 0)
 	{
@@ -171,6 +179,7 @@ _gnutls_x509_cert_verify_peers (gnutls_s
 
   /* Verify certificate 
    */
+  
   ret = gnutls_x509_crt_list_verify (peer_certificate_list,
 				     peer_certificate_list_size,
 				     cred->x509_ca_list, cred->x509_ncas,
diff -up gnutls-2.8.5/lib/includes/gnutls/gnutls.h.in.tls12 gnutls-2.8.5/lib/includes/gnutls/gnutls.h.in
--- gnutls-2.8.5/lib/includes/gnutls/gnutls.h.in.tls12	2012-04-27 17:16:04.310094556 +0200
+++ gnutls-2.8.5/lib/includes/gnutls/gnutls.h.in	2012-04-30 16:39:48.755571576 +0200
@@ -144,6 +144,7 @@ extern "C" {
    */
   typedef enum
   {
+    GNUTLS_DIG_UNKNOWN = GNUTLS_MAC_UNKNOWN,
     GNUTLS_DIG_NULL = GNUTLS_MAC_NULL,
     GNUTLS_DIG_MD5 = GNUTLS_MAC_MD5,
     GNUTLS_DIG_SHA1 = GNUTLS_MAC_SHA1,
@@ -333,6 +334,7 @@ extern "C" {
   const char *
   gnutls_sign_algorithm_get_name (gnutls_sign_algorithm_t sign);
 
+                    
 /* If you want to change this, then also change the define in
  * gnutls_int.h, and recompile.
  */
@@ -399,6 +401,9 @@ extern "C" {
   gnutls_compression_get (gnutls_session_t session);
   gnutls_certificate_type_t
   gnutls_certificate_type_get (gnutls_session_t session);
+  int gnutls_sign_algorithm_get_requested (gnutls_session_t session,
+					   size_t indx,
+					   gnutls_sign_algorithm_t *algo);
 
   size_t gnutls_cipher_get_key_size (gnutls_cipher_algorithm_t algorithm);
   size_t gnutls_mac_get_key_size (gnutls_mac_algorithm_t algorithm);
@@ -1373,6 +1378,7 @@ extern "C" {
 #define GNUTLS_E_IA_VERIFY_FAILED -104
 
 #define GNUTLS_E_UNKNOWN_ALGORITHM -105
+#define GNUTLS_E_UNSUPPORTED_SIGNATURE_ALGORITHM -106
 #define GNUTLS_E_SAFE_RENEGOTIATION_FAILED -107
 #define GNUTLS_E_UNSAFE_RENEGOTIATION_DENIED -108
 #define GNUTLS_E_UNKNOWN_SRP_USERNAME -109
diff -up gnutls-2.8.5/lib/libgnutls.map.tls12 gnutls-2.8.5/lib/libgnutls.map
--- gnutls-2.8.5/lib/libgnutls.map.tls12	2012-04-27 17:16:04.000000000 +0200
+++ gnutls-2.8.5/lib/libgnutls.map	2012-04-30 16:53:33.690917961 +0200
@@ -570,6 +570,7 @@ GNUTLS_2_8
 GNUTLS_2_10
 {
   global:
+    gnutls_sign_algorithm_get_requested;
     gnutls_safe_renegotiation_status;
 } GNUTLS_2_8;
 
diff -up gnutls-2.8.5/lib/Makefile.in.tls12 gnutls-2.8.5/lib/Makefile.in
--- gnutls-2.8.5/lib/Makefile.in.tls12	2012-04-27 17:16:04.000000000 +0200
+++ gnutls-2.8.5/lib/Makefile.in	2012-04-30 15:39:50.343075493 +0200
@@ -214,7 +214,7 @@ am__objects_4 = gnutls_record.lo gnutls_
 	ext_server_name.lo auth_dh_common.lo gnutls_helper.lo \
 	gnutls_supplemental.lo crypto.lo random.lo pk-libgcrypt.lo \
 	mpi-libgcrypt.lo rnd-libgcrypt.lo cipher-libgcrypt.lo \
-	mac-libgcrypt.lo ext_safe_renegotiation.lo $(am__objects_3)
+	mac-libgcrypt.lo ext_safe_renegotiation.lo ext_signature.lo $(am__objects_3)
 am__objects_5 = ext_srp.lo gnutls_srp.lo auth_srp.lo \
 	auth_srp_passwd.lo auth_srp_sb64.lo auth_srp_rsa.lo
 am__objects_6 = auth_psk.lo auth_psk_passwd.lo gnutls_psk.lo \
@@ -854,7 +854,7 @@ COBJECTS = gnutls_record.c gnutls_compre
 	auth_dh_common.c gnutls_helper.c gnutls_supplemental.c \
 	crypto.c random.c pk-libgcrypt.c mpi-libgcrypt.c \
 	rnd-libgcrypt.c cipher-libgcrypt.c mac-libgcrypt.c \
-	ext_safe_renegotiation.c \
+	ext_safe_renegotiation.c ext_signature.c \
 	$(am__append_5)
 HFILES = debug.h gnutls_compress.h gnutls_cipher.h gnutls_buffers.h	\
 	gnutls_errors.h gnutls_int.h gnutls_handshake.h gnutls_num.h	\
@@ -870,7 +870,7 @@ HFILES = debug.h gnutls_compress.h gnutl
 	ext_srp.h gnutls_srp.h auth_srp.h auth_srp_passwd.h		\
 	gnutls_helper.h auth_psk.h auth_psk_passwd.h			\
 	gnutls_supplemental.h ext_oprfi.h crypto.h random.h		\
-	ext_safe_renegotiation.h
+	ext_safe_renegotiation.h ext_signature.h
 
 
 # Separate so we can create the documentation
@@ -1061,6 +1061,7 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libgnutlsxx_la-gnutlsxx.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mac-libgcrypt.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext_safe_renegotiation.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext_signature.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mpi-libgcrypt.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pk-libgcrypt.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pkix_asn1_tab.Plo@am__quote@
diff -up gnutls-2.8.5/lib/openpgp/gnutls_openpgp.c.tls12 gnutls-2.8.5/lib/openpgp/gnutls_openpgp.c
--- gnutls-2.8.5/lib/openpgp/gnutls_openpgp.c.tls12	2009-08-12 08:58:13.000000000 +0200
+++ gnutls-2.8.5/lib/openpgp/gnutls_openpgp.c	2012-04-30 15:36:14.889288875 +0200
@@ -800,6 +800,8 @@ _gnutls_openpgp_crt_to_gcert (gnutls_cer
 
   memset (gcert, 0, sizeof (gnutls_cert));
   gcert->cert_type = GNUTLS_CRT_OPENPGP;
+  gcert->sign_algo = GNUTLS_SIGN_UNKNOWN; /* N/A here */
+
   gcert->version = gnutls_openpgp_crt_get_version (cert);
   gcert->params_size = MAX_PUBLIC_PARAMS_SIZE;
 
diff -up gnutls-2.8.5/src/cli.c.tls12 gnutls-2.8.5/src/cli.c
--- gnutls-2.8.5/src/cli.c.tls12	2012-04-27 17:16:04.314094644 +0200
+++ gnutls-2.8.5/src/cli.c	2012-05-03 14:48:29.921189607 +0200
@@ -365,10 +365,49 @@ cert_callback (gnutls_session_t session,
 
   st->type = gnutls_certificate_type_get (session);
 
+
   st->ncerts = 0;
 
   if (st->type == GNUTLS_CRT_X509)
     {
+      gnutls_sign_algorithm_t cert_algo, req_algo;
+      int i, match = 0;
+      
+      if (x509_crt[0] != NULL)
+        {
+          ret = gnutls_x509_crt_get_signature_algorithm(x509_crt[0]);
+          if (ret < 0)
+            {
+              /* error reading signature algorithm */
+              return -1;
+            }
+          cert_algo = ret;
+    
+          i=0;
+          do {
+            ret = gnutls_sign_algorithm_get_requested(session, i, &req_algo);
+            if (ret >= 0 && cert_algo == req_algo)
+              {
+                match = 1;
+                break;
+              }
+          
+              /* server has not requested anything specific */
+             if (i==0 && ret == GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE)
+              {
+                match = 1;
+                break;
+              }
+            i++;
+          } while(ret >= 0);
+      
+          if (match == 0)
+            {
+              printf("- Could not find a suitable certificate to send to server\n");
+              return -1;
+            }
+        }
+
       if (x509_crt != NULL && x509_key != NULL)
 	{
 	  st->ncerts = x509_crt_size;
