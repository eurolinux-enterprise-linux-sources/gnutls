diff --git a/lib/opencdk/pubkey.c b/lib/opencdk/pubkey.c
index 835e6b5..bb58486 100644
--- a/lib/opencdk/pubkey.c
+++ b/lib/opencdk/pubkey.c
@@ -537,6 +537,7 @@ cdk_pk_get_keyid (cdk_pubkey_t pk, u32 * keyid)
 {
   u32 lowbits = 0;
   byte buf[24];
+  int rc;
 
   if (pk && (!pk->keyid[0] || !pk->keyid[1]))
     {
@@ -546,7 +547,13 @@ cdk_pk_get_keyid (cdk_pubkey_t pk, u32 * keyid)
           size_t n;
 
           n = MAX_MPI_BYTES;
-          _gnutls_mpi_print (pk->mpi[0], p, &n);
+          rc = _gnutls_mpi_print (pk->mpi[0], p, &n);
+          if (rc < 0 || n < 8)
+            {
+              keyid[0] = keyid[1] = (u32)-1;
+              return (u32)-1;
+            }
+
           pk->keyid[0] =
             p[n - 8] << 24 | p[n - 7] << 16 | p[n - 6] << 8 | p[n - 5];
           pk->keyid[1] =
diff --git a/lib/opencdk/read-packet.c b/lib/opencdk/read-packet.c
index a49d4fe..ab2821b 100644
--- a/lib/opencdk/read-packet.c
+++ b/lib/opencdk/read-packet.c
@@ -42,8 +42,14 @@
 static int
 stream_read (cdk_stream_t s, void *buf, size_t buflen, size_t * r_nread)
 {
-  *r_nread = cdk_stream_read (s, buf, buflen);
-  return *r_nread > 0 ? 0 : _cdk_stream_get_errno (s);
+  int res = cdk_stream_read (s, buf, buflen);
+
+  if (res > 0) {
+    *r_nread = res;
+    return 0;
+  } else {
+    return (cdk_stream_eof(s) ? EOF : _cdk_stream_get_errno(s));
+  }
 }
 
 
@@ -52,7 +58,7 @@ static u32
 read_32 (cdk_stream_t s)
 {
   byte buf[4];
-  size_t nread;
+  size_t nread = 0;
 
   assert (s != NULL);
 
@@ -68,7 +74,7 @@ static u16
 read_16 (cdk_stream_t s)
 {
   byte buf[2];
-  size_t nread;
+  size_t nread = 0;
 
   assert (s != NULL);
 
@@ -495,14 +501,20 @@ read_attribute (cdk_stream_t inp, size_t pktlen, cdk_pkt_userid_t attr)
   rc = stream_read (inp, buf, pktlen, &nread);
   if (rc)
     {
-      cdk_free (buf);
-      return CDK_Inv_Packet;
+      rc = CDK_Inv_Packet;
+      goto error;
     }
   p = buf;
   len = *p++;
   pktlen--;
   if (len == 255)
     {
+      if (pktlen < 4)
+        {
+          gnutls_assert();
+          rc = CDK_Inv_Packet;
+          goto error;
+        }
       len = _cdk_buftou32 (p);
       p += 4;
       pktlen -= 4;
@@ -512,33 +524,41 @@ read_attribute (cdk_stream_t inp, size_t pktlen, cdk_pkt_userid_t attr)
       if (pktlen < 2)
         {
           cdk_free (buf);
-          return CDK_Inv_Packet;
+          rc = CDK_Inv_Packet;
+          goto error;
         }
       len = ((len - 192) << 8) + *p + 192;
       p++;
       pktlen--;
     }
 
-  if (*p != 1)                  /* Currently only 1, meaning an image, is defined. */
+  if (!len || *p != 1)                  /* Currently only 1, meaning an image, is defined. */
     {
-      cdk_free (buf);
-      return CDK_Inv_Packet;
+      rc = CDK_Inv_Packet;
+      goto error;
     }
   p++;
   len--;
 
   if (len >= pktlen)
-    return CDK_Inv_Packet;
+    {
+      rc = CDK_Inv_Packet;
+      goto error;
+    }
   attr->attrib_img = cdk_calloc (1, len);
   if (!attr->attrib_img)
     {
-      cdk_free (buf);
-      return CDK_Out_Of_Core;
+      rc = CDK_Out_Of_Core;
+      goto error;
     }
   attr->attrib_len = len;
   memcpy (attr->attrib_img, p, len);
   cdk_free (buf);
   return rc;
+
+error:
+  cdk_free (buf);
+  return rc;
 }
 
 
@@ -570,7 +590,7 @@ read_user_id (cdk_stream_t inp, size_t pktlen, cdk_pkt_userid_t user_id)
 static cdk_error_t
 read_subpkt (cdk_stream_t inp, cdk_subpkt_t * r_ctx, size_t * r_nbytes)
 {
-  byte c, c1;
+  int c, c1;
   size_t size, nread, n;
   cdk_subpkt_t node;
   cdk_error_t rc;
@@ -588,11 +608,16 @@ read_subpkt (cdk_stream_t inp, cdk_subpkt_t * r_ctx, size_t * r_nbytes)
   if (c == 255)
     {
       size = read_32 (inp);
+      if (size == (u32)-1)
+        return CDK_Inv_Packet;
       n += 4;
     }
   else if (c >= 192 && c < 255)
     {
       c1 = cdk_stream_getc (inp);
+      if (c1 == EOF)
+        return CDK_Inv_Packet;
+
       n++;
       if (c1 == 0)
         return 0;
@@ -860,24 +885,36 @@ static void
 read_old_length (cdk_stream_t inp, int ctb, size_t * r_len, size_t * r_size)
 {
   int llen = ctb & 0x03;
+  int c;
 
   if (llen == 0)
     {
-      *r_len = cdk_stream_getc (inp);
+      c = cdk_stream_getc(inp);
+      if (c == EOF)
+        goto fail;
+
+      *r_len = c;
       (*r_size)++;
     }
   else if (llen == 1)
     {
       *r_len = read_16 (inp);
+      if (*r_len == (u16)-1)
+        goto fail;
+
       (*r_size) += 2;
     }
   else if (llen == 2)
     {
       *r_len = read_32 (inp);
+      if (*r_len == (u32)-1)
+        goto fail;
+
       (*r_size) += 4;
     }
   else
     {
+ fail:
       *r_len = 0;
       *r_size = 0;
     }
@@ -892,18 +929,26 @@ read_new_length (cdk_stream_t inp,
   int c, c1;
 
   c = cdk_stream_getc (inp);
+  if (c == EOF)
+    return;
+
   (*r_size)++;
   if (c < 192)
     *r_len = c;
   else if (c >= 192 && c <= 223)
     {
       c1 = cdk_stream_getc (inp);
+      if (c1 == EOF)
+        return;
       (*r_size)++;
       *r_len = ((c - 192) << 8) + c1 + 192;
     }
   else if (c == 255)
     {
-      *r_len = read_32 (inp);
+      c1 = read_32 (inp);
+      if (c1 == (u32)-1)
+        return;
+      *r_len = c1;
       (*r_size) += 4;
     }
   else
@@ -915,7 +960,7 @@ read_new_length (cdk_stream_t inp,
 
 
 /* Skip the current packet body. */
-static void
+static cdk_error_t
 skip_packet (cdk_stream_t inp, size_t pktlen)
 {
   byte buf[BUFSIZE];
@@ -923,11 +968,15 @@ skip_packet (cdk_stream_t inp, size_t pktlen)
 
   while (pktlen > 0)
     {
-      stream_read (inp, buf, pktlen > buflen ? buflen : pktlen, &nread);
+      cdk_error_t rc;
+      rc = stream_read (inp, buf, pktlen > buflen ? buflen : pktlen, &nread);
+      if (rc)
+        return rc;
       pktlen -= nread;
     }
 
   assert (pktlen == 0);
+  return 0;
 }
 
 
@@ -1097,7 +1146,10 @@ cdk_pkt_read (cdk_stream_t inp, cdk_packet_t pkt)
 
     default:
       /* Skip all packets we don't understand */
-      skip_packet (inp, pktlen);
+      rc = skip_packet (inp, pktlen);
+      if (rc)
+        return rc;
+
       break;
     }
 
diff --git a/tests/openpgp-certs/Makefile.am b/tests/openpgp-certs/Makefile.am
index c252a5a..0920e26 100644
--- a/tests/openpgp-certs/Makefile.am
+++ b/tests/openpgp-certs/Makefile.am
@@ -29,7 +29,7 @@ dist_check_SCRIPTS = testselfsigs testcerts
 if ENABLE_OPENPGP
 # The selftest is disabled until we can make it work under Wine and
 # under Debian buildds (problem with 127.0.0.2?).
-TESTS = testselfsigs #testcerts
+TESTS = testselfsigs openpgp-cert-parser #testcerts
 endif
 
 TESTS_ENVIRONMENT = EXEEXT=$(EXEEXT)
diff --git a/tests/openpgp-certs/data/openpgp-invalid1.pub b/tests/openpgp-certs/data/openpgp-invalid1.pub
new file mode 100644
index 0000000..dd38a04
Binary files /dev/null and b/tests/openpgp-certs/data/openpgp-invalid1.pub differ
diff --git a/tests/openpgp-certs/data/openpgp-invalid2.pub b/tests/openpgp-certs/data/openpgp-invalid2.pub
new file mode 100644
index 0000000..93d9df5
Binary files /dev/null and b/tests/openpgp-certs/data/openpgp-invalid2.pub differ
diff --git a/tests/openpgp-certs/data/openpgp-invalid3.pub b/tests/openpgp-certs/data/openpgp-invalid3.pub
new file mode 100644
index 0000000..65d1b59
Binary files /dev/null and b/tests/openpgp-certs/data/openpgp-invalid3.pub differ
diff --git a/tests/openpgp-certs/data/openpgp-invalid4.pub b/tests/openpgp-certs/data/openpgp-invalid4.pub
new file mode 100644
index 0000000..5bd7dea
--- /dev/null
+++ b/tests/openpgp-certs/data/openpgp-invalid4.pub
@@ -0,0 +1 @@
+¶
\ No newline at end of file
diff --git a/tests/openpgp-certs/data/truncated.pub b/tests/openpgp-certs/data/truncated.pub
new file mode 100644
index 0000000..29e181e
--- /dev/null
+++ b/tests/openpgp-certs/data/truncated.pub
@@ -0,0 +1 @@
+ÿ
diff --git a/tests/openpgp-certs/openpgp-cert-parser b/tests/openpgp-certs/openpgp-cert-parser
new file mode 100755
index 0000000..66e3d31
--- /dev/null
+++ b/tests/openpgp-certs/openpgp-cert-parser
@@ -0,0 +1,52 @@
+#!/bin/sh
+
+# Copyright (C) 2010, 2012 Free Software Foundation, Inc.
+#
+# Author: Nikos Mavrogiannopoulos
+#
+# This file is part of GnuTLS.
+#
+# GnuTLS is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the
+# Free Software Foundation; either version 3 of the License, or (at
+# your option) any later version.
+#
+# GnuTLS is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GnuTLS; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+
+srcdir="${srcdir:-.}"
+CERTTOOL="${CERTTOOL:-../../src/certtool${EXEEXT}}"
+
+if ! test -z "${VALGRIND}"; then
+	VALGRIND="${LIBTOOL:-libtool} --mode=execute ${VALGRIND}"
+fi
+
+if ! test -x "${CERTTOOL}"; then
+	exit 77
+fi
+
+unset RETCODE || true
+
+fail() {
+	 echo "Failure: $1" >&2
+	 RETCODE=${RETCODE:-${2:-1}}
+}
+
+echo "Checking OpenPGP certificate parsing"
+
+for i in "truncated.pub" "openpgp-invalid1.pub" \
+	"openpgp-invalid2.pub" "openpgp-invalid3.pub" "openpgp-invalid4.pub";do
+	${VALGRIND} "${CERTTOOL}" --inraw --pgp-certificate-info --infile "${srcdir}/data/${i}"
+	rc=$?
+	if test $rc != 1;then
+		fail "$i: Parsing should have errored ($rc)"
+	fi
+done
+
+exit ${RETCODE:-0}
